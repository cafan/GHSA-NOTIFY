<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Container Software GHSA Feeds</title>
    <link>https://raw.githubusercontent.com/ssst0n3/GHSA-NOTIFY/main/output/feed.xml</link>
    <description></description>
    <managingEditor>ssst0n3@gmail.com (ssst0n3)</managingEditor>
    <pubDate>Thu, 09 Nov 2023 05:10:17 +0000</pubDate>
    <item>
      <title>/sys/devices/virtual/powercap accessible by default to containers</title>
      <link>https://github.com/advisories/GHSA-jq35-85cj-fj4p</link>
      <description>Intel&#39;s RAPL (Running Average Power Limit) feature, introduced by the Sandy Bridge microarchitecture, provides software insights into hardware energy consumption. To facilitate this, Intel introduced the powercap framework in Linux kernel 3.13, which reads values via relevant MSRs (model specific registers) and provides unprivileged userspace access via `sysfs`. As RAPL is an interface to access a hardware feature, it is only available when running on bare metal with the module compiled into the kernel.&#xA;&#xA;By 2019, it was realized that in some cases unprivileged access to RAPL readings could be exploited as a power-based side-channel against security features including AES-NI (potentially inside a SGX enclave) and KASLR (kernel address space layout randomization). Also known as the [PLATYPUS attack](https://platypusattack.com/), Intel assigned [CVE-2020-8694](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8694) and [CVE-2020-8695](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8695), and AMD assigned [CVE-2020-12912](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-12912).&#xA;&#xA;Several mitigations were applied; Intel reduced the sampling resolution via a microcode update, and the Linux kernel [prevents access by non-root users](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71) since 5.10. However, this kernel-based mitigation does not apply to many container-based scenarios:&#xA;* Unless using user namespaces, root inside a container has the same level of privilege as root outside the container, but with a slightly more narrow view of the system&#xA;* `sysfs` is mounted inside containers read-only; however only read access is needed to carry out this attack on an unpatched CPU&#xA;&#xA;While this is not a direct vulnerability in container runtimes, defense in depth and safe defaults are valuable and preferred, especially as this poses a risk to multi-tenant container environments running directly on affected hardware. This is provided by masking `/sys/devices/virtual/powercap` in the default mount configuration, and adding an additional set of rules to deny it in the default AppArmor profile.&#xA;&#xA;While `sysfs` is not the only way to read from the RAPL subsystem, other ways of accessing it require additional capabilities such as `CAP_SYS_RAWIO` which is not available to containers by default, or `perf` paranoia level less than 1, which is a non-default kernel tunable.&#xA;&#xA;## References&#xA;&#xA;* https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8694&#xA;* https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8695&#xA;* https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-12912&#xA;* https://platypusattack.com/&#xA;* https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71&#xA;* https://web.eece.maine.edu/~vweaver/projects/rapl/</description>
      <pubDate>Mon, 30 Oct 2023 15:25:44 +0000</pubDate>
    </item>
    <item>
      <title>Secret insertion into debug log in Docker</title>
      <link>https://github.com/advisories/GHSA-j249-ghv5-7mxv</link>
      <description>In Docker CE and EE before 18.09.8 (as well as Docker EE before 17.06.2-ee-23 and 18.x before 18.03.1-ee-10), Docker Engine in debug mode may sometimes add secrets to the debug log. This applies to a scenario where docker stack deploy is run to redeploy a stack that includes (non external) secrets. It potentially applies to other API users of the stack API if they resend the secret.</description>
      <pubDate>Tue, 15 Aug 2023 20:17:39 +0000</pubDate>
    </item>
    <item>
      <title>Docker Swarm encrypted overlay network may be unauthenticated</title>
      <link>https://github.com/advisories/GHSA-232p-vwff-86mp</link>
      <description>[Moby](https://mobyproject.org/) is an open source container framework developed by Docker Inc. that is distributed as Docker, Mirantis Container Runtime, and various other downstream projects/products. The Moby daemon component (`dockerd`), which is developed as [moby/moby](https://github.com/moby/moby) is commonly referred to as *Docker*.&#xA;&#xA;Swarm Mode, which is compiled in and delivered by default in `dockerd` and is thus present in most major Moby downstreams, is a simple, built-in container orchestrator that is implemented through a combination of [SwarmKit](https://github.com/moby/swarmkit) and supporting network code.&#xA;&#xA;The `overlay` network driver is a core feature of Swarm Mode, providing isolated virtual LANs that allow communication between containers and services across the cluster. This driver is an implementation/user of [VXLAN](https://en.wikipedia.org/wiki/Virtual_Extensible_LAN), which encapsulates link-layer (Ethernet) frames in UDP datagrams that tag the frame with a VXLAN Network ID (VNI) that identifies the originating overlay network. In addition, the overlay network driver supports an optional, off-by-default encrypted mode, which is especially useful when VXLAN packets traverses an untrusted network between nodes.&#xA;&#xA;Encrypted overlay networks function by encapsulating the VXLAN datagrams through the use of the [IPsec Encapsulating Security Payload](https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload) protocol in [Transport mode](https://en.wikipedia.org/wiki/IPsec#Transport_mode). By deploying IPSec encapsulation, encrypted overlay networks gain the additional properties of source authentication through cryptographic proof, data integrity through check-summing, and confidentiality through encryption.&#xA;&#xA;When setting an endpoint up on an encrypted overlay network, Moby installs three [iptables](https://www.netfilter.org/projects/iptables/index.html) (Linux kernel firewall) rules that enforce both incoming and outgoing IPSec. These rules rely on the `u32` iptables extension provided by the `xt_u32` kernel module to directly filter on a VXLAN packet&#39;s VNI field, so that IPSec guarantees can be enforced on encrypted overlay networks without interfering with other overlay networks or other users of VXLAN.&#xA;&#xA;[Two iptables rules](https://github.com/moby/libnetwork/blob/d9fae4c73daf76c3b0f77e14b45b8bf612ba764d/drivers/overlay/encryption.go#L230-L234) serve to filter incoming VXLAN datagrams with a VNI that corresponds to an encrypted network and discards unencrypted datagrams. The rules are appended to the end of the `INPUT` filter chain, following any rules that have been previously set by the system administrator. Administrator-set rules take precedence over the rules Moby sets to discard unencrypted VXLAN datagrams, which can potentially admit unencrypted datagrams that should have been discarded.&#xA;&#xA;On Red Hat Enterprise Linux and derivatives such as CentOS and Rocky, the `xt_u32` module has been:&#xA;* [moved to the kernel-modules-extra package and no longer installed by default in RHEL 8.3](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.3_release_notes/rhel-8-3-0-release#technology-preview_networking)&#xA;* [officially deprecated in RHEL 8.6](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.6_release_notes/deprecated_functionality#deprecated-functionality_networking)&#xA;* [removed completely in RHEL 9](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/considerations_in_adopting_rhel_9/assembly_networking_considerations-in-adopting-rhel-9#ref_firewall-networking_assembly_networking)&#xA;&#xA;These rules are not created when `xt_u32` is unavailable, even though the container is still attached to the network.&#xA;&#xA;## Impact&#xA;Encrypted overlay networks on affected configurations silently accept cleartext VXLAN datagrams that are tagged with the VNI of an encrypted overlay network. As a result, it is possible to inject arbitrary Ethernet frames into the encrypted overlay network by encapsulating them in VXLAN datagrams.&#xA;&#xA;The injection of arbitrary Ethernet frames can enable a Denial of Service attack. A sophisticated attacker may be able to establish a UDP or TCP connection by way of the container’s outbound gateway that would otherwise be blocked by a stateful firewall, or carry out other escalations beyond simple injection by smuggling packets into the overlay network.&#xA;&#xA;## Patches&#xA;Patches are available in Moby releases 23.0.3, and 20.10.24. As Mirantis Container Runtime&#39;s 20.10 releases are numbered differently, users of that platform should update to 20.10.16.&#xA;&#xA;## Workarounds&#xA;* Close the VXLAN port (by default, UDP port 4789) to incoming traffic at the Internet boundary (see [GHSA-vwm3-crmr-xfxw](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)) to prevent all VXLAN packet injection.&#xA;* Ensure that the `xt_u32` kernel module is available on all nodes of the Swarm cluster.&#xA;&#xA;## Background&#xA;* [#43382](https://github.com/moby/moby/issues/43382) partially discussed this concern, but did not consider the security implications.&#xA;* Mirantis FIELD-5788 essentially duplicates [#43382](https://github.com/moby/moby/issues/43382), and was created six months earlier; it similarly overlooked the security implications.&#xA;* [#45118](https://github.com/moby/moby/pull/45118) is the ancestor of the final patches, and was where the security implications were discovered.&#xA;&#xA;## Related&#xA;* [CVE-2023-28841: Encrypted overlay network traffic may be unencrypted](https://github.com/moby/moby/security/advisories/GHSA-33pg-m6jh-5237)&#xA;* [CVE-2023-28842: Encrypted overlay network with a single endpoint is unauthenticated](https://github.com/moby/moby/security/advisories/GHSA-6wrf-mxfj-pf5p)&#xA;* [GHSA-vwm3-crmr-xfxw: The Swarm VXLAN port may be exposed to attack due to ambiguous documentation](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)&#xA;* [GHSA-gvm4-2qqg-m333: Security issues in encrypted overlay networks](https://github.com/moby/libnetwork/security/advisories/GHSA-gvm4-2qqg-m333) (libnetwork)</description>
      <pubDate>Wed, 05 Apr 2023 23:16:24 +0000</pubDate>
    </item>
    <item>
      <title>Docker Swarm encrypted overlay network may be unauthenticated</title>
      <link>https://github.com/advisories/GHSA-232p-vwff-86mp</link>
      <description>[Moby](https://mobyproject.org/) is an open source container framework developed by Docker Inc. that is distributed as Docker, Mirantis Container Runtime, and various other downstream projects/products. The Moby daemon component (`dockerd`), which is developed as [moby/moby](https://github.com/moby/moby) is commonly referred to as *Docker*.&#xA;&#xA;Swarm Mode, which is compiled in and delivered by default in `dockerd` and is thus present in most major Moby downstreams, is a simple, built-in container orchestrator that is implemented through a combination of [SwarmKit](https://github.com/moby/swarmkit) and supporting network code.&#xA;&#xA;The `overlay` network driver is a core feature of Swarm Mode, providing isolated virtual LANs that allow communication between containers and services across the cluster. This driver is an implementation/user of [VXLAN](https://en.wikipedia.org/wiki/Virtual_Extensible_LAN), which encapsulates link-layer (Ethernet) frames in UDP datagrams that tag the frame with a VXLAN Network ID (VNI) that identifies the originating overlay network. In addition, the overlay network driver supports an optional, off-by-default encrypted mode, which is especially useful when VXLAN packets traverses an untrusted network between nodes.&#xA;&#xA;Encrypted overlay networks function by encapsulating the VXLAN datagrams through the use of the [IPsec Encapsulating Security Payload](https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload) protocol in [Transport mode](https://en.wikipedia.org/wiki/IPsec#Transport_mode). By deploying IPSec encapsulation, encrypted overlay networks gain the additional properties of source authentication through cryptographic proof, data integrity through check-summing, and confidentiality through encryption.&#xA;&#xA;When setting an endpoint up on an encrypted overlay network, Moby installs three [iptables](https://www.netfilter.org/projects/iptables/index.html) (Linux kernel firewall) rules that enforce both incoming and outgoing IPSec. These rules rely on the `u32` iptables extension provided by the `xt_u32` kernel module to directly filter on a VXLAN packet&#39;s VNI field, so that IPSec guarantees can be enforced on encrypted overlay networks without interfering with other overlay networks or other users of VXLAN.&#xA;&#xA;[Two iptables rules](https://github.com/moby/libnetwork/blob/d9fae4c73daf76c3b0f77e14b45b8bf612ba764d/drivers/overlay/encryption.go#L230-L234) serve to filter incoming VXLAN datagrams with a VNI that corresponds to an encrypted network and discards unencrypted datagrams. The rules are appended to the end of the `INPUT` filter chain, following any rules that have been previously set by the system administrator. Administrator-set rules take precedence over the rules Moby sets to discard unencrypted VXLAN datagrams, which can potentially admit unencrypted datagrams that should have been discarded.&#xA;&#xA;On Red Hat Enterprise Linux and derivatives such as CentOS and Rocky, the `xt_u32` module has been:&#xA;* [moved to the kernel-modules-extra package and no longer installed by default in RHEL 8.3](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.3_release_notes/rhel-8-3-0-release#technology-preview_networking)&#xA;* [officially deprecated in RHEL 8.6](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.6_release_notes/deprecated_functionality#deprecated-functionality_networking)&#xA;* [removed completely in RHEL 9](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/considerations_in_adopting_rhel_9/assembly_networking_considerations-in-adopting-rhel-9#ref_firewall-networking_assembly_networking)&#xA;&#xA;These rules are not created when `xt_u32` is unavailable, even though the container is still attached to the network.&#xA;&#xA;## Impact&#xA;Encrypted overlay networks on affected configurations silently accept cleartext VXLAN datagrams that are tagged with the VNI of an encrypted overlay network. As a result, it is possible to inject arbitrary Ethernet frames into the encrypted overlay network by encapsulating them in VXLAN datagrams.&#xA;&#xA;The injection of arbitrary Ethernet frames can enable a Denial of Service attack. A sophisticated attacker may be able to establish a UDP or TCP connection by way of the container’s outbound gateway that would otherwise be blocked by a stateful firewall, or carry out other escalations beyond simple injection by smuggling packets into the overlay network.&#xA;&#xA;## Patches&#xA;Patches are available in Moby releases 23.0.3, and 20.10.24. As Mirantis Container Runtime&#39;s 20.10 releases are numbered differently, users of that platform should update to 20.10.16.&#xA;&#xA;## Workarounds&#xA;* Close the VXLAN port (by default, UDP port 4789) to incoming traffic at the Internet boundary (see [GHSA-vwm3-crmr-xfxw](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)) to prevent all VXLAN packet injection.&#xA;* Ensure that the `xt_u32` kernel module is available on all nodes of the Swarm cluster.&#xA;&#xA;## Background&#xA;* [#43382](https://github.com/moby/moby/issues/43382) partially discussed this concern, but did not consider the security implications.&#xA;* Mirantis FIELD-5788 essentially duplicates [#43382](https://github.com/moby/moby/issues/43382), and was created six months earlier; it similarly overlooked the security implications.&#xA;* [#45118](https://github.com/moby/moby/pull/45118) is the ancestor of the final patches, and was where the security implications were discovered.&#xA;&#xA;## Related&#xA;* [CVE-2023-28841: Encrypted overlay network traffic may be unencrypted](https://github.com/moby/moby/security/advisories/GHSA-33pg-m6jh-5237)&#xA;* [CVE-2023-28842: Encrypted overlay network with a single endpoint is unauthenticated](https://github.com/moby/moby/security/advisories/GHSA-6wrf-mxfj-pf5p)&#xA;* [GHSA-vwm3-crmr-xfxw: The Swarm VXLAN port may be exposed to attack due to ambiguous documentation](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)&#xA;* [GHSA-gvm4-2qqg-m333: Security issues in encrypted overlay networks](https://github.com/moby/libnetwork/security/advisories/GHSA-gvm4-2qqg-m333) (libnetwork)</description>
      <pubDate>Wed, 05 Apr 2023 23:16:24 +0000</pubDate>
    </item>
    <item>
      <title>Docker Swarm encrypted overlay network traffic may be unencrypted</title>
      <link>https://github.com/advisories/GHSA-33pg-m6jh-5237</link>
      <description>[Moby](https://mobyproject.org/) is an open source container framework developed by Docker Inc. that is distributed as Docker, Mirantis Container Runtime, and various other downstream projects/products. The Moby daemon component (`dockerd`), which is developed as [moby/moby](https://github.com/moby/moby) is commonly referred to as *Docker*.&#xA;&#xA;Swarm Mode, which is compiled in and delivered by default in `dockerd` and is thus present in most major Moby downstreams, is a simple, built-in container orchestrator that is implemented through a combination of [SwarmKit](https://github.com/moby/swarmkit) and supporting network code.&#xA;&#xA;The `overlay` network driver is a core feature of Swarm Mode, providing isolated virtual LANs that allow communication between containers and services across the cluster. This driver is an implementation/user of [VXLAN](https://en.wikipedia.org/wiki/Virtual_Extensible_LAN), which encapsulates link-layer (Ethernet) frames in UDP datagrams that tag the frame with a VXLAN Network ID (VNI) that identifies the originating overlay network. In addition, the overlay network driver supports an optional, off-by-default encrypted mode, which is especially useful when VXLAN packets traverses an untrusted network between nodes.&#xA;&#xA;Encrypted overlay networks function by encapsulating the VXLAN datagrams through the use of the [IPsec Encapsulating Security Payload](https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload) protocol in [Transport mode](https://en.wikipedia.org/wiki/IPsec#Transport_mode). By deploying IPSec encapsulation, encrypted overlay networks gain the additional properties of source authentication through cryptographic proof, data integrity through check-summing, and confidentiality through encryption.&#xA;&#xA;When setting an endpoint up on an encrypted overlay network, Moby installs three [iptables](https://www.netfilter.org/projects/iptables/index.html) (Linux kernel firewall) rules that enforce both incoming and outgoing IPSec. These rules rely on the `u32` iptables extension provided by the `xt_u32` kernel module to directly filter on a VXLAN packet&#39;s VNI field, so that IPSec guarantees can be enforced on encrypted overlay networks without interfering with other overlay networks or other users of VXLAN.&#xA;&#xA;An [iptables rule](https://github.com/moby/libnetwork/blob/d9fae4c73daf76c3b0f77e14b45b8bf612ba764d/drivers/overlay/encryption.go#L205-L207) designates outgoing VXLAN datagrams with a VNI that corresponds to an encrypted overlay network for IPsec encapsulation.&#xA;&#xA;On Red Hat Enterprise Linux and derivatives such as CentOS and Rocky, the `xt_u32` module has been:&#xA;* [moved to the kernel-modules-extra package and no longer installed by default in RHEL 8.3](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.3_release_notes/rhel-8-3-0-release#technology-preview_networking)&#xA;* [officially deprecated in RHEL 8.6](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.6_release_notes/deprecated_functionality#deprecated-functionality_networking)&#xA;* [removed completely in RHEL 9](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/considerations_in_adopting_rhel_9/assembly_networking_considerations-in-adopting-rhel-9#ref_firewall-networking_assembly_networking)&#xA;&#xA;This rule is not created when `xt_u32` is unavailable, even though the container is still attached to the network.&#xA;&#xA;## Impact&#xA;Encrypted overlay networks on affected platforms silently transmit unencrypted data. As a result, `overlay` networks may appear to be functional, passing traffic as expected, but without any of the expected confidentiality or data integrity guarantees.&#xA;&#xA;It is possible for an attacker sitting in a trusted position on the network to read all of the application traffic that is moving across the overlay network, resulting in unexpected secrets or user data disclosure. Thus, because many database protocols, internal APIs, etc. are not protected by a second layer of encryption, a user may rely on Swarm encrypted overlay networks to provide confidentiality, which due to this vulnerability is no longer guaranteed.&#xA;&#xA;## Patches&#xA;Patches are available in Moby releases 23.0.3, and 20.10.24. As Mirantis Container Runtime&#39;s 20.10 releases are numbered differently, users of that platform should update to 20.10.16.&#xA;&#xA;## Workarounds&#xA;* Close the VXLAN port (by default, UDP port 4789) to outgoing traffic at the Internet boundary (see [GHSA-vwm3-crmr-xfxw](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)) in order to prevent unintentionally leaking unencrypted traffic over the Internet.&#xA;* Ensure that the `xt_u32` kernel module is available on all nodes of the Swarm cluster.&#xA;&#xA;## Background&#xA;* [#43382 ](https://github.com/moby/moby/issues/43382)partially discussed this concern, but did not consider the security implications.&#xA;* Mirantis FIELD-5788 essentially duplicates [#43382](https://github.com/moby/moby/issues/43382), and was created six months earlier; it similarly overlooked the security implications.&#xA;* [#45118](https://github.com/moby/moby/pull/45118) is the ancestor of the final patches, and was where the security implications were discovered.&#xA;&#xA;## Related&#xA;* [CVE-2023-28840: Encrypted overlay network may be unauthenticated](https://github.com/moby/moby/security/advisories/GHSA-232p-vwff-86mp)&#xA;* [CVE-2023-28842: Encrypted overlay network with a single endpoint is unauthenticated](https://github.com/moby/moby/security/advisories/GHSA-6wrf-mxfj-pf5p)&#xA;* [GHSA-vwm3-crmr-xfxw: The Swarm VXLAN port may be exposed to attack due to ambiguous documentation](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)&#xA;* [GHSA-gvm4-2qqg-m333: Security issues in encrypted overlay networks](https://github.com/moby/libnetwork/security/advisories/GHSA-gvm4-2qqg-m333) (libnetwork)</description>
      <pubDate>Tue, 18 Apr 2023 22:03:56 +0000</pubDate>
    </item>
    <item>
      <title>Docker Swarm encrypted overlay network traffic may be unencrypted</title>
      <link>https://github.com/advisories/GHSA-33pg-m6jh-5237</link>
      <description>[Moby](https://mobyproject.org/) is an open source container framework developed by Docker Inc. that is distributed as Docker, Mirantis Container Runtime, and various other downstream projects/products. The Moby daemon component (`dockerd`), which is developed as [moby/moby](https://github.com/moby/moby) is commonly referred to as *Docker*.&#xA;&#xA;Swarm Mode, which is compiled in and delivered by default in `dockerd` and is thus present in most major Moby downstreams, is a simple, built-in container orchestrator that is implemented through a combination of [SwarmKit](https://github.com/moby/swarmkit) and supporting network code.&#xA;&#xA;The `overlay` network driver is a core feature of Swarm Mode, providing isolated virtual LANs that allow communication between containers and services across the cluster. This driver is an implementation/user of [VXLAN](https://en.wikipedia.org/wiki/Virtual_Extensible_LAN), which encapsulates link-layer (Ethernet) frames in UDP datagrams that tag the frame with a VXLAN Network ID (VNI) that identifies the originating overlay network. In addition, the overlay network driver supports an optional, off-by-default encrypted mode, which is especially useful when VXLAN packets traverses an untrusted network between nodes.&#xA;&#xA;Encrypted overlay networks function by encapsulating the VXLAN datagrams through the use of the [IPsec Encapsulating Security Payload](https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload) protocol in [Transport mode](https://en.wikipedia.org/wiki/IPsec#Transport_mode). By deploying IPSec encapsulation, encrypted overlay networks gain the additional properties of source authentication through cryptographic proof, data integrity through check-summing, and confidentiality through encryption.&#xA;&#xA;When setting an endpoint up on an encrypted overlay network, Moby installs three [iptables](https://www.netfilter.org/projects/iptables/index.html) (Linux kernel firewall) rules that enforce both incoming and outgoing IPSec. These rules rely on the `u32` iptables extension provided by the `xt_u32` kernel module to directly filter on a VXLAN packet&#39;s VNI field, so that IPSec guarantees can be enforced on encrypted overlay networks without interfering with other overlay networks or other users of VXLAN.&#xA;&#xA;An [iptables rule](https://github.com/moby/libnetwork/blob/d9fae4c73daf76c3b0f77e14b45b8bf612ba764d/drivers/overlay/encryption.go#L205-L207) designates outgoing VXLAN datagrams with a VNI that corresponds to an encrypted overlay network for IPsec encapsulation.&#xA;&#xA;On Red Hat Enterprise Linux and derivatives such as CentOS and Rocky, the `xt_u32` module has been:&#xA;* [moved to the kernel-modules-extra package and no longer installed by default in RHEL 8.3](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.3_release_notes/rhel-8-3-0-release#technology-preview_networking)&#xA;* [officially deprecated in RHEL 8.6](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.6_release_notes/deprecated_functionality#deprecated-functionality_networking)&#xA;* [removed completely in RHEL 9](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/considerations_in_adopting_rhel_9/assembly_networking_considerations-in-adopting-rhel-9#ref_firewall-networking_assembly_networking)&#xA;&#xA;This rule is not created when `xt_u32` is unavailable, even though the container is still attached to the network.&#xA;&#xA;## Impact&#xA;Encrypted overlay networks on affected platforms silently transmit unencrypted data. As a result, `overlay` networks may appear to be functional, passing traffic as expected, but without any of the expected confidentiality or data integrity guarantees.&#xA;&#xA;It is possible for an attacker sitting in a trusted position on the network to read all of the application traffic that is moving across the overlay network, resulting in unexpected secrets or user data disclosure. Thus, because many database protocols, internal APIs, etc. are not protected by a second layer of encryption, a user may rely on Swarm encrypted overlay networks to provide confidentiality, which due to this vulnerability is no longer guaranteed.&#xA;&#xA;## Patches&#xA;Patches are available in Moby releases 23.0.3, and 20.10.24. As Mirantis Container Runtime&#39;s 20.10 releases are numbered differently, users of that platform should update to 20.10.16.&#xA;&#xA;## Workarounds&#xA;* Close the VXLAN port (by default, UDP port 4789) to outgoing traffic at the Internet boundary (see [GHSA-vwm3-crmr-xfxw](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)) in order to prevent unintentionally leaking unencrypted traffic over the Internet.&#xA;* Ensure that the `xt_u32` kernel module is available on all nodes of the Swarm cluster.&#xA;&#xA;## Background&#xA;* [#43382 ](https://github.com/moby/moby/issues/43382)partially discussed this concern, but did not consider the security implications.&#xA;* Mirantis FIELD-5788 essentially duplicates [#43382](https://github.com/moby/moby/issues/43382), and was created six months earlier; it similarly overlooked the security implications.&#xA;* [#45118](https://github.com/moby/moby/pull/45118) is the ancestor of the final patches, and was where the security implications were discovered.&#xA;&#xA;## Related&#xA;* [CVE-2023-28840: Encrypted overlay network may be unauthenticated](https://github.com/moby/moby/security/advisories/GHSA-232p-vwff-86mp)&#xA;* [CVE-2023-28842: Encrypted overlay network with a single endpoint is unauthenticated](https://github.com/moby/moby/security/advisories/GHSA-6wrf-mxfj-pf5p)&#xA;* [GHSA-vwm3-crmr-xfxw: The Swarm VXLAN port may be exposed to attack due to ambiguous documentation](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)&#xA;* [GHSA-gvm4-2qqg-m333: Security issues in encrypted overlay networks](https://github.com/moby/libnetwork/security/advisories/GHSA-gvm4-2qqg-m333) (libnetwork)</description>
      <pubDate>Tue, 18 Apr 2023 22:03:56 +0000</pubDate>
    </item>
    <item>
      <title>Docker Swarm encrypted overlay network with a single endpoint is unauthenticated</title>
      <link>https://github.com/advisories/GHSA-6wrf-mxfj-pf5p</link>
      <description>[Moby](https://mobyproject.org/) is an open source container framework developed by Docker Inc. that is distributed as Docker, Mirantis Container Runtime, and various other downstream projects/products. The Moby daemon component (`dockerd`), which is developed as [moby/moby](https://github.com/moby/moby) is commonly referred to as *Docker*.&#xA;&#xA;Swarm Mode, which is compiled in and delivered by default in `dockerd` and is thus present in most major Moby downstreams, is a simple, built-in container orchestrator that is implemented through a combination of [SwarmKit](https://github.com/moby/swarmkit) and supporting network code.&#xA;&#xA;The `overlay` network driver is a core feature of Swarm Mode, providing isolated virtual LANs that allow communication between containers and services across the cluster. This driver is an implementation/user of [VXLAN](https://en.wikipedia.org/wiki/Virtual_Extensible_LAN), which encapsulates link-layer (Ethernet) frames in UDP datagrams that tag the frame with a VXLAN Network ID (VNI) that identifies the originating overlay network. In addition, the overlay network driver supports an optional, off-by-default encrypted mode, which is especially useful when VXLAN packets traverses an untrusted network between nodes.&#xA;&#xA;Encrypted overlay networks function by encapsulating the VXLAN datagrams through the use of the [IPsec Encapsulating Security Payload](https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload) protocol in [Transport mode](https://en.wikipedia.org/wiki/IPsec#Transport_mode). By deploying IPSec encapsulation, encrypted overlay networks gain the additional properties of source authentication through cryptographic proof, data integrity through check-summing, and confidentiality through encryption.&#xA;&#xA;When setting an endpoint up on an encrypted overlay network, Moby installs three [iptables](https://www.netfilter.org/projects/iptables/index.html) (Linux kernel firewall) rules that enforce both incoming and outgoing IPSec. These rules rely on the `u32` iptables extension provided by the `xt_u32` kernel module to directly filter on a VXLAN packet&#39;s VNI field, so that IPSec guarantees can be enforced on encrypted overlay networks without interfering with other overlay networks or other users of VXLAN.&#xA;&#xA;The `overlay` driver dynamically and lazily defines the kernel configuration for the VXLAN network on each node as containers are attached and detached. Routes and encryption parameters are only defined for destination nodes that participate in the network. The iptables rules that prevent encrypted overlay networks from accepting unencrypted packets are not created until a peer is available with which to communicate.&#xA;&#xA;## Impact&#xA;Encrypted overlay networks silently accept cleartext VXLAN datagrams that are tagged with the VNI of an encrypted overlay network. As a result, it is possible to inject arbitrary Ethernet frames into the encrypted overlay network by encapsulating them in VXLAN datagrams. The implications of this can be quite dire, and [GHSA-vwm3-crmr-xfxw](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw) should be referenced for a deeper exploration.&#xA;&#xA;## Patches&#xA;Patches are available in Moby releases 23.0.3, and 20.10.24. As Mirantis Container Runtime&#39;s 20.10 releases are numbered differently, users of that platform should update to 20.10.16.&#xA;&#xA;## Workarounds&#xA;* In multi-node clusters, deploy a global ‘pause’ container for each encrypted overlay network, on every node. For example, use the `registry.k8s.io/pause` image and a `--mode global` service.&#xA;* For a single-node cluster, do not use overlay networks of any sort. Bridge networks provide the same connectivity on a single node and have no multi-node features.&#xA;The Swarm ingress feature is implemented using an overlay network, but can be disabled by publishing ports in `host` mode instead of `ingress` mode (allowing the use of an external load balancer), and removing the `ingress` network.&#xA;* If encrypted overlay networks are in exclusive use, block UDP port 4789 from traffic that has not been validated by IPSec. For example, `iptables -A INPUT -m udp —-dport 4789 -m policy --dir in --pol none -j DROP`.&#xA;&#xA;## Background&#xA;* This issue was discovered while characterizing and mitigating [CVE-2023-28840](https://github.com/moby/moby/security/advisories/GHSA-232p-vwff-86mp) and [CVE-2023-28841](https://github.com/moby/moby/security/advisories/GHSA-33pg-m6jh-5237).&#xA;&#xA;## Related&#xA;* [CVE-2023-28841: Encrypted overlay network traffic may be unencrypted](https://github.com/moby/moby/security/advisories/GHSA-33pg-m6jh-5237)&#xA;* [CVE-2023-28840: Encrypted overlay network may be unauthenticated](https://github.com/moby/moby/security/advisories/GHSA-232p-vwff-86mp)&#xA;* [GHSA-vwm3-crmr-xfxw: The Swarm VXLAN port may be exposed to attack due to ambiguous documentation](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)&#xA;* [GHSA-gvm4-2qqg-m333: Security issues in encrypted overlay networks](https://github.com/moby/libnetwork/security/advisories/GHSA-gvm4-2qqg-m333) (libnetwork)</description>
      <pubDate>Tue, 18 Apr 2023 22:04:07 +0000</pubDate>
    </item>
    <item>
      <title>Docker Swarm encrypted overlay network with a single endpoint is unauthenticated</title>
      <link>https://github.com/advisories/GHSA-6wrf-mxfj-pf5p</link>
      <description>[Moby](https://mobyproject.org/) is an open source container framework developed by Docker Inc. that is distributed as Docker, Mirantis Container Runtime, and various other downstream projects/products. The Moby daemon component (`dockerd`), which is developed as [moby/moby](https://github.com/moby/moby) is commonly referred to as *Docker*.&#xA;&#xA;Swarm Mode, which is compiled in and delivered by default in `dockerd` and is thus present in most major Moby downstreams, is a simple, built-in container orchestrator that is implemented through a combination of [SwarmKit](https://github.com/moby/swarmkit) and supporting network code.&#xA;&#xA;The `overlay` network driver is a core feature of Swarm Mode, providing isolated virtual LANs that allow communication between containers and services across the cluster. This driver is an implementation/user of [VXLAN](https://en.wikipedia.org/wiki/Virtual_Extensible_LAN), which encapsulates link-layer (Ethernet) frames in UDP datagrams that tag the frame with a VXLAN Network ID (VNI) that identifies the originating overlay network. In addition, the overlay network driver supports an optional, off-by-default encrypted mode, which is especially useful when VXLAN packets traverses an untrusted network between nodes.&#xA;&#xA;Encrypted overlay networks function by encapsulating the VXLAN datagrams through the use of the [IPsec Encapsulating Security Payload](https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload) protocol in [Transport mode](https://en.wikipedia.org/wiki/IPsec#Transport_mode). By deploying IPSec encapsulation, encrypted overlay networks gain the additional properties of source authentication through cryptographic proof, data integrity through check-summing, and confidentiality through encryption.&#xA;&#xA;When setting an endpoint up on an encrypted overlay network, Moby installs three [iptables](https://www.netfilter.org/projects/iptables/index.html) (Linux kernel firewall) rules that enforce both incoming and outgoing IPSec. These rules rely on the `u32` iptables extension provided by the `xt_u32` kernel module to directly filter on a VXLAN packet&#39;s VNI field, so that IPSec guarantees can be enforced on encrypted overlay networks without interfering with other overlay networks or other users of VXLAN.&#xA;&#xA;The `overlay` driver dynamically and lazily defines the kernel configuration for the VXLAN network on each node as containers are attached and detached. Routes and encryption parameters are only defined for destination nodes that participate in the network. The iptables rules that prevent encrypted overlay networks from accepting unencrypted packets are not created until a peer is available with which to communicate.&#xA;&#xA;## Impact&#xA;Encrypted overlay networks silently accept cleartext VXLAN datagrams that are tagged with the VNI of an encrypted overlay network. As a result, it is possible to inject arbitrary Ethernet frames into the encrypted overlay network by encapsulating them in VXLAN datagrams. The implications of this can be quite dire, and [GHSA-vwm3-crmr-xfxw](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw) should be referenced for a deeper exploration.&#xA;&#xA;## Patches&#xA;Patches are available in Moby releases 23.0.3, and 20.10.24. As Mirantis Container Runtime&#39;s 20.10 releases are numbered differently, users of that platform should update to 20.10.16.&#xA;&#xA;## Workarounds&#xA;* In multi-node clusters, deploy a global ‘pause’ container for each encrypted overlay network, on every node. For example, use the `registry.k8s.io/pause` image and a `--mode global` service.&#xA;* For a single-node cluster, do not use overlay networks of any sort. Bridge networks provide the same connectivity on a single node and have no multi-node features.&#xA;The Swarm ingress feature is implemented using an overlay network, but can be disabled by publishing ports in `host` mode instead of `ingress` mode (allowing the use of an external load balancer), and removing the `ingress` network.&#xA;* If encrypted overlay networks are in exclusive use, block UDP port 4789 from traffic that has not been validated by IPSec. For example, `iptables -A INPUT -m udp —-dport 4789 -m policy --dir in --pol none -j DROP`.&#xA;&#xA;## Background&#xA;* This issue was discovered while characterizing and mitigating [CVE-2023-28840](https://github.com/moby/moby/security/advisories/GHSA-232p-vwff-86mp) and [CVE-2023-28841](https://github.com/moby/moby/security/advisories/GHSA-33pg-m6jh-5237).&#xA;&#xA;## Related&#xA;* [CVE-2023-28841: Encrypted overlay network traffic may be unencrypted](https://github.com/moby/moby/security/advisories/GHSA-33pg-m6jh-5237)&#xA;* [CVE-2023-28840: Encrypted overlay network may be unauthenticated](https://github.com/moby/moby/security/advisories/GHSA-232p-vwff-86mp)&#xA;* [GHSA-vwm3-crmr-xfxw: The Swarm VXLAN port may be exposed to attack due to ambiguous documentation](https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw)&#xA;* [GHSA-gvm4-2qqg-m333: Security issues in encrypted overlay networks](https://github.com/moby/libnetwork/security/advisories/GHSA-gvm4-2qqg-m333) (libnetwork)</description>
      <pubDate>Tue, 18 Apr 2023 22:04:07 +0000</pubDate>
    </item>
    <item>
      <title>Path Traversal in Docker</title>
      <link>https://github.com/advisories/GHSA-vj3f-3286-r4pf</link>
      <description>Path traversal vulnerability in Docker before 1.3.3 allows remote attackers to write to arbitrary files and bypass a container protection mechanism via a full pathname in a symlink in an (1) image or (2) build in a Dockerfile.</description>
      <pubDate>Mon, 09 Jan 2023 05:04:29 +0000</pubDate>
    </item>
    <item>
      <title>Privilege Escalation in Docker</title>
      <link>https://github.com/advisories/GHSA-wxj3-qwv4-cvfm</link>
      <description>Docker 1.0.0 uses world-readable and world-writable permissions on the management socket, which allows local users to gain privileges via unspecified vectors.</description>
      <pubDate>Tue, 21 Feb 2023 05:06:24 +0000</pubDate>
    </item>
    <item>
      <title>Arbitrary Code Execution in Docker</title>
      <link>https://github.com/advisories/GHSA-5qgp-p5jc-w2rm</link>
      <description>Docker before 1.3.2 allows remote attackers to write to arbitrary files and execute arbitrary code via a (1) symlink or (2) hard link attack in an image archive in a (a) pull or (b) load operation.</description>
      <pubDate>Mon, 09 Jan 2023 05:04:33 +0000</pubDate>
    </item>
    <item>
      <title>Directory Traversal in Docker</title>
      <link>https://github.com/advisories/GHSA-qmmc-jppf-32wv</link>
      <description>Docker before 1.3.3 does not properly validate image IDs, which allows remote attackers to conduct path traversal attacks and spoof repositories via a crafted image in a (1) &#34;docker load&#34; operation or (2) &#34;registry communications.&#34;</description>
      <pubDate>Mon, 09 Jan 2023 05:04:48 +0000</pubDate>
    </item>
    <item>
      <title>Symlink Attack in Libcontainer and Docker Engine</title>
      <link>https://github.com/advisories/GHSA-g7v2-2qxx-wjrw</link>
      <description>Libcontainer and Docker Engine before 1.6.1 opens the file-descriptor passed to the pid-1 process before performing the chroot, which allows local users to gain privileges via a symlink attack in an image.</description>
      <pubDate>Mon, 09 Jan 2023 05:05:16 +0000</pubDate>
    </item>
    <item>
      <title>Access Restriction Bypass in Docker</title>
      <link>https://github.com/advisories/GHSA-44gg-pmqr-4669</link>
      <description>Docker 1.3.0 through 1.3.1 allows remote attackers to modify the default run profile of image containers and possibly bypass the container by applying unspecified security options to an image.</description>
      <pubDate>Mon, 09 Jan 2023 05:04:47 +0000</pubDate>
    </item>
    <item>
      <title>Arbitrary File Write in Libcontainer</title>
      <link>https://github.com/advisories/GHSA-g44j-7vp3-68cv</link>
      <description>Libcontainer 1.6.0, as used in Docker Engine, allows local users to escape containerization (&#34;mount namespace breakout&#34;) and write to arbitrary file on the host system via a symlink attack in an image when respawning a container.</description>
      <pubDate>Mon, 09 Jan 2023 05:04:56 +0000</pubDate>
    </item>
    <item>
      <title>Man-in-the-Middle (MitM)</title>
      <link>https://github.com/advisories/GHSA-8w94-cf6g-c8mg</link>
      <description>Docker before 1.3.1 and docker-py before 0.5.3 fall back to HTTP when the HTTPS connection to the registry fails, which allows man-in-the-middle attackers to conduct downgrade attacks and obtain authentication and image data by leveraging a network position between the client and the registry to block HTTPS traffic.</description>
      <pubDate>Mon, 09 Jan 2023 05:04:42 +0000</pubDate>
    </item>
    <item>
      <title>Arbitrary Code Execution</title>
      <link>https://github.com/advisories/GHSA-997c-fj8j-rq5h</link>
      <description>Docker 1.3.2 allows remote attackers to execute arbitrary code with root privileges via a crafted (1) image or (2) build in a Dockerfile in an LZMA (.xz) archive, related to the chroot for archive extraction.</description>
      <pubDate>Mon, 09 Jan 2023 05:04:27 +0000</pubDate>
    </item>
    <item>
      <title>containerd-shim API Exposed to Host Network Containers</title>
      <link>https://github.com/advisories/GHSA-36xw-fx78-c5r4</link>
      <description>## Impact&#xA;&#xA;Access controls for the shim’s API socket verified that the connecting process had an effective UID of 0, but did not otherwise restrict access to the abstract Unix domain socket. This would allow malicious containers running in the same network namespace as the shim, with an effective UID of 0 but otherwise reduced privileges, to cause new processes to be run with elevated privileges.&#xA;&#xA;### Specific Go Packages Affected&#xA;github.com/containerd/containerd/cmd&#xA;&#xA;## Patches&#xA;&#xA;This vulnerability has been fixed in containerd 1.3.9 and 1.4.3.  Users should update to these versions as soon as they are released.  It should be noted that containers started with an old version of containerd-shim should be stopped and restarted, as running containers will continue to be vulnerable even after an upgrade.&#xA;&#xA;## Workarounds&#xA;&#xA;If you are not providing the ability for untrusted users to start containers in the same network namespace as the shim (typically the &#34;host&#34; network namespace, for example with `docker run --net=host` or `hostNetwork: true` in a Kubernetes pod) and run with an effective UID of 0, you are not vulnerable to this issue.&#xA;&#xA;If you are running containers with a vulnerable configuration, you can deny access to all abstract sockets with AppArmor by adding a line similar to `deny unix addr=@**,` to your policy.&#xA;&#xA;It is best practice to run containers with a reduced set of privileges, with a non-zero UID, and with isolated namespaces.  The containerd maintainers strongly advise against sharing namespaces with the host. Reducing the set of isolation mechanisms used for a container necessarily increases that container&#39;s privilege, regardless of what container runtime is used for running that container.&#xA;&#xA;## Credits&#xA;&#xA;The containerd maintainers would like to thank Jeff Dileo of NCC Group for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/master/SECURITY.md) and for reviewing the patch.&#xA;&#xA;## For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;&#xA;* [Open an issue](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at security@containerd.io if you think you’ve found a security bug.</description>
      <pubDate>Mon, 02 Oct 2023 15:37:36 +0000</pubDate>
    </item>
    <item>
      <title>containerd-shim API Exposed to Host Network Containers</title>
      <link>https://github.com/advisories/GHSA-36xw-fx78-c5r4</link>
      <description>## Impact&#xA;&#xA;Access controls for the shim’s API socket verified that the connecting process had an effective UID of 0, but did not otherwise restrict access to the abstract Unix domain socket. This would allow malicious containers running in the same network namespace as the shim, with an effective UID of 0 but otherwise reduced privileges, to cause new processes to be run with elevated privileges.&#xA;&#xA;### Specific Go Packages Affected&#xA;github.com/containerd/containerd/cmd&#xA;&#xA;## Patches&#xA;&#xA;This vulnerability has been fixed in containerd 1.3.9 and 1.4.3.  Users should update to these versions as soon as they are released.  It should be noted that containers started with an old version of containerd-shim should be stopped and restarted, as running containers will continue to be vulnerable even after an upgrade.&#xA;&#xA;## Workarounds&#xA;&#xA;If you are not providing the ability for untrusted users to start containers in the same network namespace as the shim (typically the &#34;host&#34; network namespace, for example with `docker run --net=host` or `hostNetwork: true` in a Kubernetes pod) and run with an effective UID of 0, you are not vulnerable to this issue.&#xA;&#xA;If you are running containers with a vulnerable configuration, you can deny access to all abstract sockets with AppArmor by adding a line similar to `deny unix addr=@**,` to your policy.&#xA;&#xA;It is best practice to run containers with a reduced set of privileges, with a non-zero UID, and with isolated namespaces.  The containerd maintainers strongly advise against sharing namespaces with the host. Reducing the set of isolation mechanisms used for a container necessarily increases that container&#39;s privilege, regardless of what container runtime is used for running that container.&#xA;&#xA;## Credits&#xA;&#xA;The containerd maintainers would like to thank Jeff Dileo of NCC Group for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/master/SECURITY.md) and for reviewing the patch.&#xA;&#xA;## For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;&#xA;* [Open an issue](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at security@containerd.io if you think you’ve found a security bug.</description>
      <pubDate>Mon, 02 Oct 2023 15:37:36 +0000</pubDate>
    </item>
    <item>
      <title>Supplementary groups are not set up properly in github.com/containerd/containerd</title>
      <link>https://github.com/advisories/GHSA-hmfx-3pcx-653p</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd where supplementary groups are not set up properly inside a container.  If an attacker has direct access to a container and manipulates their supplementary group access, they may be able to use supplementary group access to bypass primary group restrictions in some cases, potentially gaining access to sensitive information or gaining the ability to execute code in that container.&#xA;&#xA;Downstream applications that use the containerd client library may be affected as well.&#xA;&#xA;### Patches&#xA;This bug has been fixed in containerd v1.6.18 and v.1.5.18.  Users should update to these versions and recreate containers to resolve this issue.  Users who rely on a downstream application that uses containerd&#39;s client library should check that application for a separate advisory and instructions.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that the `&#34;USER $USERNAME&#34;` Dockerfile instruction is not used.  Instead, set the container entrypoint to a value similar to `ENTRYPOINT [&#34;su&#34;, &#34;-&#34;, &#34;user&#34;]` to allow `su` to properly set up supplementary groups.&#xA;&#xA;### References&#xA;&#xA;- https://www.benthamsgaze.org/2022/08/22/vulnerability-in-linux-containers-investigation-and-mitigation/&#xA;- Docker/Moby: CVE-2022-36109, fixed in Docker 20.10.18&#xA;- CRI-O: CVE-2022-2995, fixed in CRI-O 1.25.0&#xA;- Podman: CVE-2022-2989, fixed in Podman 3.0.1 and 4.2.0&#xA;- Buildah: CVE-2022-2990, fixed in Buildah 1.27.1&#xA;&#xA;Note that CVE IDs apply to a particular implementation, even if an issue is common.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;&#xA;To report a security issue in containerd:&#xA;* [Report a new vulnerability](https://github.com/containerd/containerd/security/advisories/new)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Wed, 20 Sep 2023 17:39:25 +0000</pubDate>
    </item>
    <item>
      <title>Supplementary groups are not set up properly in github.com/containerd/containerd</title>
      <link>https://github.com/advisories/GHSA-hmfx-3pcx-653p</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd where supplementary groups are not set up properly inside a container.  If an attacker has direct access to a container and manipulates their supplementary group access, they may be able to use supplementary group access to bypass primary group restrictions in some cases, potentially gaining access to sensitive information or gaining the ability to execute code in that container.&#xA;&#xA;Downstream applications that use the containerd client library may be affected as well.&#xA;&#xA;### Patches&#xA;This bug has been fixed in containerd v1.6.18 and v.1.5.18.  Users should update to these versions and recreate containers to resolve this issue.  Users who rely on a downstream application that uses containerd&#39;s client library should check that application for a separate advisory and instructions.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that the `&#34;USER $USERNAME&#34;` Dockerfile instruction is not used.  Instead, set the container entrypoint to a value similar to `ENTRYPOINT [&#34;su&#34;, &#34;-&#34;, &#34;user&#34;]` to allow `su` to properly set up supplementary groups.&#xA;&#xA;### References&#xA;&#xA;- https://www.benthamsgaze.org/2022/08/22/vulnerability-in-linux-containers-investigation-and-mitigation/&#xA;- Docker/Moby: CVE-2022-36109, fixed in Docker 20.10.18&#xA;- CRI-O: CVE-2022-2995, fixed in CRI-O 1.25.0&#xA;- Podman: CVE-2022-2989, fixed in Podman 3.0.1 and 4.2.0&#xA;- Buildah: CVE-2022-2990, fixed in Buildah 1.27.1&#xA;&#xA;Note that CVE IDs apply to a particular implementation, even if an issue is common.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;&#xA;To report a security issue in containerd:&#xA;* [Report a new vulnerability](https://github.com/containerd/containerd/security/advisories/new)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Wed, 20 Sep 2023 17:39:25 +0000</pubDate>
    </item>
    <item>
      <title>OCI image importer memory exhaustion in github.com/containerd/containerd</title>
      <link>https://github.com/advisories/GHSA-259w-8hf6-59c2</link>
      <description>### Impact&#xA;&#xA;When importing an OCI image, there was no limit on the number of bytes read for certain files. A maliciously crafted image with a large file where a limit was not applied could cause a denial of service.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.18 and 1.5.18.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images are used and that only trusted users have permissions to import images. &#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank [David Korczynski](https://github.com/DavidKorczynski) and [Adam Korczynski](https://github.com/AdamKorcz) of ADA Logics for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md) during a security fuzzing audit sponsored by CNCF.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;&#xA;To report a security issue in containerd:&#xA;* [Report a new vulnerability](https://github.com/containerd/containerd/security/advisories/new)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Tue, 13 Jun 2023 23:55:09 +0000</pubDate>
    </item>
    <item>
      <title>OCI image importer memory exhaustion in github.com/containerd/containerd</title>
      <link>https://github.com/advisories/GHSA-259w-8hf6-59c2</link>
      <description>### Impact&#xA;&#xA;When importing an OCI image, there was no limit on the number of bytes read for certain files. A maliciously crafted image with a large file where a limit was not applied could cause a denial of service.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.18 and 1.5.18.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images are used and that only trusted users have permissions to import images. &#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank [David Korczynski](https://github.com/DavidKorczynski) and [Adam Korczynski](https://github.com/AdamKorcz) of ADA Logics for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md) during a security fuzzing audit sponsored by CNCF.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;&#xA;To report a security issue in containerd:&#xA;* [Report a new vulnerability](https://github.com/containerd/containerd/security/advisories/new)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Tue, 13 Jun 2023 23:55:09 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI stream server vulnerable to host memory exhaustion via terminal</title>
      <link>https://github.com/advisories/GHSA-2qjp-425j-52j9</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd&#39;s CRI implementation where a user can exhaust memory on the host. In the CRI stream server, a goroutine is launched to handle terminal resize events if a TTY is requested. If the user&#39;s process fails to launch due to, for example, a faulty command, the goroutine will be stuck waiting to send without a receiver, resulting in a memory leak. Kubernetes and crictl can both be configured to use containerd&#39;s CRI implementation and the stream server is used for handling container IO.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.12 and 1.5.16.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images and commands are used and that only trusted users have permissions to execute commands in running containers. &#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;&#xA;To report a security issue in containerd:&#xA;* [Report a new vulnerability](https://github.com/containerd/containerd/security/advisories/new)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Wed, 12 Jul 2023 14:02:07 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI stream server vulnerable to host memory exhaustion via terminal</title>
      <link>https://github.com/advisories/GHSA-2qjp-425j-52j9</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd&#39;s CRI implementation where a user can exhaust memory on the host. In the CRI stream server, a goroutine is launched to handle terminal resize events if a TTY is requested. If the user&#39;s process fails to launch due to, for example, a faulty command, the goroutine will be stuck waiting to send without a receiver, resulting in a memory leak. Kubernetes and crictl can both be configured to use containerd&#39;s CRI implementation and the stream server is used for handling container IO.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.12 and 1.5.16.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images and commands are used and that only trusted users have permissions to execute commands in running containers. &#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;&#xA;To report a security issue in containerd:&#xA;* [Report a new vulnerability](https://github.com/containerd/containerd/security/advisories/new)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Wed, 12 Jul 2023 14:02:07 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI plugin: Host memory exhaustion through ExecSync</title>
      <link>https://github.com/advisories/GHSA-5ffw-gxpp-mxpf</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd&#39;s CRI implementation where programs inside a container can cause the containerd daemon to consume memory without bound during invocation of the `ExecSync` API.  This can cause containerd to consume all available memory on the computer, denying service to other legitimate workloads.  Kubernetes and crictl can both be configured to use containerd&#39;s CRI implementation; `ExecSync` may be used when running probes or when executing processes via an &#34;exec&#34; facility.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.6 and 1.5.13.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images and commands are used. &#xA;&#xA;### References&#xA;&#xA;* Similar fix in cri-o&#39;s CRI implementation https://github.com/cri-o/cri-o/security/advisories/GHSA-fcm2-6c3h-pg6j&#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank David Korczynski and Adam Korczynski of ADA Logics for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md) during a security audit sponsored by CNCF and facilitated by OSTIF.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Fri, 27 Jan 2023 05:03:24 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI plugin: Host memory exhaustion through ExecSync</title>
      <link>https://github.com/advisories/GHSA-5ffw-gxpp-mxpf</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd&#39;s CRI implementation where programs inside a container can cause the containerd daemon to consume memory without bound during invocation of the `ExecSync` API.  This can cause containerd to consume all available memory on the computer, denying service to other legitimate workloads.  Kubernetes and crictl can both be configured to use containerd&#39;s CRI implementation; `ExecSync` may be used when running probes or when executing processes via an &#34;exec&#34; facility.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.6 and 1.5.13.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images and commands are used. &#xA;&#xA;### References&#xA;&#xA;* Similar fix in cri-o&#39;s CRI implementation https://github.com/cri-o/cri-o/security/advisories/GHSA-fcm2-6c3h-pg6j&#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank David Korczynski and Adam Korczynski of ADA Logics for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md) during a security audit sponsored by CNCF and facilitated by OSTIF.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Fri, 27 Jan 2023 05:03:24 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI plugin: Insecure handling of image volumes</title>
      <link>https://github.com/advisories/GHSA-crp2-qrr5-8pq7</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd where containers launched through containerd’s CRI implementation with a specially-crafted image configuration could gain access to read-only copies of arbitrary files and directories on the host.  This may bypass any policy-based enforcement on container setup (including a Kubernetes Pod Security Policy) and expose potentially sensitive information.  Kubernetes and crictl can both be configured to use containerd’s CRI implementation.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.1, 1.5.10 and 1.4.13.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images are used.&#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank Felix Wilhelm of Google Project Zero for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md).&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Fri, 03 Feb 2023 05:06:28 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI plugin: Insecure handling of image volumes</title>
      <link>https://github.com/advisories/GHSA-crp2-qrr5-8pq7</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd where containers launched through containerd’s CRI implementation with a specially-crafted image configuration could gain access to read-only copies of arbitrary files and directories on the host.  This may bypass any policy-based enforcement on container setup (including a Kubernetes Pod Security Policy) and expose potentially sensitive information.  Kubernetes and crictl can both be configured to use containerd’s CRI implementation.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.1, 1.5.10 and 1.4.13.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images are used.&#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank Felix Wilhelm of Google Project Zero for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md).&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Fri, 03 Feb 2023 05:06:28 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI plugin: Insecure handling of image volumes</title>
      <link>https://github.com/advisories/GHSA-crp2-qrr5-8pq7</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd where containers launched through containerd’s CRI implementation with a specially-crafted image configuration could gain access to read-only copies of arbitrary files and directories on the host.  This may bypass any policy-based enforcement on container setup (including a Kubernetes Pod Security Policy) and expose potentially sensitive information.  Kubernetes and crictl can both be configured to use containerd’s CRI implementation.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.1, 1.5.10 and 1.4.13.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images are used.&#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank Felix Wilhelm of Google Project Zero for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md).&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Fri, 03 Feb 2023 05:06:28 +0000</pubDate>
    </item>
    <item>
      <title>Unprivileged pod using `hostPath` can side-step active LSM when it is SELinux</title>
      <link>https://github.com/advisories/GHSA-mvff-h3cj-wj9c</link>
      <description>### Impact&#xA;&#xA;Containers launched through containerd’s CRI implementation on Linux systems which use the SELinux security module and containerd versions since v1.5.0 can cause arbitrary files and directories on the host to be relabeled to match the container process label through the use of specially-configured bind mounts in a hostPath volume. This relabeling elevates permissions for the container, granting full read/write access over the affected files and directories. Kubernetes and crictl can both be configured to use containerd’s CRI implementation.&#xA;&#xA;If you are not using containerd’s CRI implementation (through one of the mechanisms described above), you are not affected by this issue.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.5.9.  Because file labels persist independently of containerd, users should both update to these versions as soon as they are released and validate that all files on their host are correctly labeled.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that no sensitive files or directories are used as a hostPath volume source location.  Policy enforcement mechanisms such a Kubernetes Pod Security Policy [AllowedHostPaths](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems) may be specified to limit the files and directories that can be bind-mounted to containers.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Fri, 03 Feb 2023 05:04:06 +0000</pubDate>
    </item>
    <item>
      <title>Ambiguous OCI manifest parsing</title>
      <link>https://github.com/advisories/GHSA-5j5w-g665-5m35</link>
      <description>### Impact&#xA;&#xA;In the OCI Distribution Specification version 1.0.0 and prior and in the OCI Image Specification version 1.0.1 and prior, manifest and index documents are ambiguous without an accompanying Content-Type HTTP header.  Versions of containerd prior to 1.4.12 and 1.5.8 treat the Content-Type header as trusted and deserialize the document according to that header.  If the Content-Type header changed between pulls of the same ambiguous document (with the same digest), the document may be interpreted differently, meaning that the digest alone is insufficient to unambiguously identify the content of the image.&#xA;&#xA;### Patches&#xA;&#xA;This issue has been fixed in containerd 1.4.12 and 1.5.8.  Image pulls for manifests that contain a “manifests” field or indices which contain a “layers” field are rejected.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure you only pull images from trusted sources.&#xA;&#xA;### References&#xA;&#xA;https://github.com/opencontainers/distribution-spec/security/advisories/GHSA-mc8v-mgrf-8f4m&#xA;https://github.com/opencontainers/image-spec/security/advisories/GHSA-77vh-xpmg-72qh&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Thu, 30 Mar 2023 14:50:05 +0000</pubDate>
    </item>
    <item>
      <title>Ambiguous OCI manifest parsing</title>
      <link>https://github.com/advisories/GHSA-5j5w-g665-5m35</link>
      <description>### Impact&#xA;&#xA;In the OCI Distribution Specification version 1.0.0 and prior and in the OCI Image Specification version 1.0.1 and prior, manifest and index documents are ambiguous without an accompanying Content-Type HTTP header.  Versions of containerd prior to 1.4.12 and 1.5.8 treat the Content-Type header as trusted and deserialize the document according to that header.  If the Content-Type header changed between pulls of the same ambiguous document (with the same digest), the document may be interpreted differently, meaning that the digest alone is insufficient to unambiguously identify the content of the image.&#xA;&#xA;### Patches&#xA;&#xA;This issue has been fixed in containerd 1.4.12 and 1.5.8.  Image pulls for manifests that contain a “manifests” field or indices which contain a “layers” field are rejected.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure you only pull images from trusted sources.&#xA;&#xA;### References&#xA;&#xA;https://github.com/opencontainers/distribution-spec/security/advisories/GHSA-mc8v-mgrf-8f4m&#xA;https://github.com/opencontainers/image-spec/security/advisories/GHSA-77vh-xpmg-72qh&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Thu, 30 Mar 2023 14:50:05 +0000</pubDate>
    </item>
    <item>
      <title>Insufficiently restricted permissions on plugin directories</title>
      <link>https://github.com/advisories/GHSA-c2h3-6mxw-7mvq</link>
      <description>### Impact&#xA;A bug was found in containerd where container root directories and some plugins had insufficiently restricted permissions, allowing otherwise unprivileged Linux users to traverse directory contents and execute programs. When containers included executable programs with extended permission bits (such as setuid), unprivileged Linux users could discover and execute those programs. When the UID of an unprivileged Linux user on the host collided with the file owner or group inside a container, the unprivileged Linux user on the host could discover, read, and modify those files.&#xA;&#xA;### Patches&#xA;This vulnerability has been fixed in containerd 1.4.11 and containerd 1.5.7. Users should update to these version when they are released and may restart containers or update directory permissions to mitigate the vulnerability.&#xA;&#xA;### Workarounds&#xA;Limit access to the host to trusted users. Update directory permission on container bundles directories. &#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory: &#xA;* Open an issue in [github.com/containerd/containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;</description>
      <pubDate>Fri, 27 Jan 2023 05:00:34 +0000</pubDate>
    </item>
    <item>
      <title>Insufficiently restricted permissions on plugin directories</title>
      <link>https://github.com/advisories/GHSA-c2h3-6mxw-7mvq</link>
      <description>### Impact&#xA;A bug was found in containerd where container root directories and some plugins had insufficiently restricted permissions, allowing otherwise unprivileged Linux users to traverse directory contents and execute programs. When containers included executable programs with extended permission bits (such as setuid), unprivileged Linux users could discover and execute those programs. When the UID of an unprivileged Linux user on the host collided with the file owner or group inside a container, the unprivileged Linux user on the host could discover, read, and modify those files.&#xA;&#xA;### Patches&#xA;This vulnerability has been fixed in containerd 1.4.11 and containerd 1.5.7. Users should update to these version when they are released and may restart containers or update directory permissions to mitigate the vulnerability.&#xA;&#xA;### Workarounds&#xA;Limit access to the host to trusted users. Update directory permission on container bundles directories. &#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory: &#xA;* Open an issue in [github.com/containerd/containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;</description>
      <pubDate>Fri, 27 Jan 2023 05:00:34 +0000</pubDate>
    </item>
    <item>
      <title>Archive package allows chmod of file outside of unpack target directory</title>
      <link>https://github.com/advisories/GHSA-c72p-9xmj-rx3w</link>
      <description>## Impact&#xA;&#xA;A bug was found in containerd where pulling and extracting a specially-crafted container image can result in Unix file permission changes for existing files in the host’s filesystem.  Changes to file permissions can deny access to the expected owner of the file, widen access to others, or set extended bits like setuid, setgid, and sticky.  This bug does not directly allow files to be read, modified, or executed without an additional cooperating process.&#xA;&#xA;## Patches&#xA;&#xA;This bug has been fixed in containerd 1.5.4 and 1.4.8.  Users should update to these versions as soon as they are released.  Running containers do not need to be restarted.&#xA;&#xA;## Workarounds&#xA;&#xA;Ensure you only pull images from trusted sources.&#xA;&#xA;Linux security modules (LSMs) like SELinux and AppArmor can limit the files potentially affected by this bug through policies and profiles that prevent containerd from interacting with unexpected files.&#xA;&#xA;## For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* [Open an issue](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at security@containerd.io if you think you’ve found a security bug.</description>
      <pubDate>Mon, 03 Apr 2023 22:38:54 +0000</pubDate>
    </item>
    <item>
      <title>Archive package allows chmod of file outside of unpack target directory</title>
      <link>https://github.com/advisories/GHSA-c72p-9xmj-rx3w</link>
      <description>## Impact&#xA;&#xA;A bug was found in containerd where pulling and extracting a specially-crafted container image can result in Unix file permission changes for existing files in the host’s filesystem.  Changes to file permissions can deny access to the expected owner of the file, widen access to others, or set extended bits like setuid, setgid, and sticky.  This bug does not directly allow files to be read, modified, or executed without an additional cooperating process.&#xA;&#xA;## Patches&#xA;&#xA;This bug has been fixed in containerd 1.5.4 and 1.4.8.  Users should update to these versions as soon as they are released.  Running containers do not need to be restarted.&#xA;&#xA;## Workarounds&#xA;&#xA;Ensure you only pull images from trusted sources.&#xA;&#xA;Linux security modules (LSMs) like SELinux and AppArmor can limit the files potentially affected by this bug through policies and profiles that prevent containerd from interacting with unexpected files.&#xA;&#xA;## For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* [Open an issue](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at security@containerd.io if you think you’ve found a security bug.</description>
      <pubDate>Mon, 03 Apr 2023 22:38:54 +0000</pubDate>
    </item>
    <item>
      <title>containerd v1.2.x can be coerced into leaking credentials during image pull</title>
      <link>https://github.com/advisories/GHSA-742w-89gc-8m9c</link>
      <description>## Impact&#xA;&#xA;If a container image manifest in the OCI Image format or Docker Image V2 Schema 2 format includes a URL for the location of a specific image layer (otherwise known as a “foreign layer”), the default containerd resolver will follow that URL to attempt to download it. In v1.2.x but not 1.3.0 or later, the default containerd resolver will provide its authentication credentials if the server where the URL is located presents an HTTP 401 status code along with registry-specific HTTP headers.&#xA;&#xA;If an attacker publishes a public image with a manifest that directs one of the layers to be fetched from a web server they control and they trick a user or system into pulling the image, they can obtain the credentials used for pulling that image. In some cases, this may be the user&#39;s username and password for the registry. In other cases, this may be the credentials attached to the cloud virtual instance which can grant access to other cloud resources in the account.&#xA;&#xA;The default containerd resolver is used by the cri-containerd plugin (which can be used by Kubernetes), the ctr development tool, and other client programs that have explicitly linked against it.&#xA;&#xA;This vulnerability has been rated by the containerd maintainers as medium, with a CVSS score of 6.1 and a vector string of CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:N/A:N.&#xA;&#xA;## Patches&#xA;&#xA;This vulnerability has been fixed in containerd 1.2.14.  containerd 1.3 and later are not affected.&#xA;&#xA;## Workarounds&#xA;&#xA;If you are using containerd 1.3 or later, you are not affected.  If you are using cri-containerd in the 1.2 series or prior, you should ensure you only pull images from trusted sources.  Other container runtimes built on top of containerd but not using the default resolver (such as Docker) are not affected.&#xA;&#xA;## Credits&#xA;&#xA;The containerd maintainers would like to thank Brad Geesaman, Josh Larsen, Ian Coldwater, Duffie Cooley, and Rory McCune for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/master/SECURITY.md).</description>
      <pubDate>Wed, 01 Feb 2023 05:05:45 +0000</pubDate>
    </item>
    <item>
      <title>Overflow in netlink bytemsg length field allows attacker to override netlink-based container configuration in RunC</title>
      <link>https://github.com/advisories/GHSA-v95c-p5hm-xq8f</link>
      <description>### Impact&#xA;&#xA;In runc, [netlink](https://www.man7.org/linux/man-pages/man7/netlink.7.html) is used internally as a serialization system for specifying the relevant container configuration to the C portion of our code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration.&#xA;&#xA;This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces.&#xA;&#xA;Prior to 9c444070ec7bb83995dbc0185da68284da71c554, in practice it was fairly difficult to specify an arbitrary-length netlink message with most container runtimes. The only user-controlled byte array was the namespace paths attributes which can be specified in runc&#39;s `config.json`, but as far as we can tell no container runtime gives raw access to that configuration setting -- and having raw access to that setting **would allow the attacker to disable namespace protections entirely anyway** (setting them to `/proc/1/ns/...` for instance). In addition, each namespace path is limited to 4096 bytes (with only 7 namespaces supported by runc at the moment) meaning that even with custom namespace paths it appears an attacker still cannot shove enough bytes into the netlink bytemsg in order to overflow the uint16 counter.&#xA;&#xA;However, out of an abundance of caution (given how old this bug is) we decided to treat it as a potentially exploitable vulnerability with a low severity. After 9c444070ec7bb83995dbc0185da68284da71c554 (which was not present in any release of runc prior to the discovery of this bug), all mount paths are included as a giant netlink message which means that this bug becomes significantly more exploitable in more reasonable threat scenarios.&#xA;&#xA;The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure), though as mentioned above it appears this bug was not practically exploitable on any released version of runc to date.&#xA;&#xA;### Patches&#xA;The patch for this is d72d057ba794164c3cce9451a00b72a78b25e1ae and runc 1.0.3 was released with this bug fixed.&#xA;&#xA;### Workarounds&#xA;To the extent this is exploitable, disallowing untrusted namespace paths in container configuration should eliminate all practical ways of exploiting this bug. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.&#xA;&#xA;### References&#xA;* commit d72d057ba794 (&#34;runc init: avoid netlink message length overflows&#34;)&#xA;* https://bugs.chromium.org/p/project-zero/issues/detail?id=2241&#xA;&#xA;### Credits&#xA;Thanks to Felix Wilhelm from Google Project Zero for discovering and reporting this vulnerability. In particular, the fact they found this vulnerability so quickly, before we made a 1.1 release of runc (which would&#39;ve been vulnerable) was quite impressive.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [our repo](https://github.com/opencontainers/runc)&#xA;</description>
      <pubDate>Tue, 29 Aug 2023 22:55:58 +0000</pubDate>
    </item>
    <item>
      <title>Privilege Elevation in runc</title>
      <link>https://github.com/advisories/GHSA-q3j5-32m5-58c2</link>
      <description>libcontainer/user/user.go in runC before 0.1.0, as used in Docker before 1.11.2, improperly treats a numeric UID as a potential username, which allows local users to gain privileges via a numeric username in the password file in a container.</description>
      <pubDate>Tue, 29 Aug 2023 22:43:33 +0000</pubDate>
    </item>
    <item>
      <title>opencontainers runc contains procfs race condition with a shared volume mount</title>
      <link>https://github.com/advisories/GHSA-fh74-hm69-rqjw</link>
      <description>### Impact&#xA;By crafting a malicious root filesystem (with `/proc` being a symlink to a directory which was inside a volume shared with another running container), an attacker in control of both containers can trick `runc` into not correctly configuring the container&#39;s security labels and not correctly masking paths inside `/proc` which contain potentially-sensitive information about the host (or even allow for direct attacks against the host).&#xA;&#xA;In order to exploit this bug, an untrusted user must be able to spawn custom containers with custom mount configurations (such that a volume is shared between two containers). It should be noted that we consider this to be a fairly high level of access for an untrusted user -- and we do not recommend allowing completely untrusted users to have such degrees of access without further restrictions.&#xA;&#xA;### Specific Go Package Affected&#xA;github.com/opencontainers/runc/libcontainer&#xA;&#xA;### Patches&#xA;This vulnerability has been fixed in `1.0.0-rc10`. It should be noted that the current fix is effectively a hot-fix, and there are known ways for it to be worked around (such as making the entire root filesystem a shared volume controlled by another container). We recommend that users review their access policies to ensure that untrusted users do not have such high levels of controls over container mount configuration.&#xA;&#xA;### Workarounds&#xA;If you are not providing the ability for untrusted users to configure mountpoints for `runc` (or through a higher-level tool such as `docker run -v`) then you are not vulnerable to this issue. This exploit requires fairly complicated levels of access (which are available for some public clouds but are not necessarily available for all deployments).&#xA;&#xA;Additionally, it appears as though it is not possible to exploit this vulnerability through Docker (due to the order of mounts Docker generates). However you should not depend on this, as it may be possible to work around this roadblock.&#xA;&#xA;### Credits&#xA;This vulnerability was discovered by Cure53, as part of a third-party security audit.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* [Open an issue](https://github.com/opencontainers/runc/issues/new).&#xA;* Email us at [dev@opencontainers.org](mailto:dev@opencontainers.org), or [security@opencontainers.org](mailto:security@opencontainers.org) if you think you&#39;ve found a security bug.</description>
      <pubDate>Wed, 25 Oct 2023 14:24:52 +0000</pubDate>
    </item>
    <item>
      <title>runc AppArmor bypass with symlinked /proc</title>
      <link>https://github.com/advisories/GHSA-g2j6-57v7-gm8c</link>
      <description>### Impact&#xA;It was found that AppArmor, and potentially SELinux, can be bypassed when `/proc` inside the container is symlinked with a specific mount configuration.&#xA;&#xA;### Patches&#xA;Fixed in runc v1.1.5, by prohibiting symlinked `/proc`: https://github.com/opencontainers/runc/pull/3785&#xA;&#xA;This PR fixes CVE-2023-27561 as well.&#xA;&#xA;### Workarounds&#xA;Avoid using an untrusted container image.&#xA;&#xA;</description>
      <pubDate>Thu, 06 Apr 2023 22:56:28 +0000</pubDate>
    </item>
    <item>
      <title>rootless: `/sys/fs/cgroup` is writable when cgroupns isn&#39;t unshared in runc</title>
      <link>https://github.com/advisories/GHSA-m8cg-xc2p-r3fc</link>
      <description>### Impact&#xA;It was found that rootless runc makes `/sys/fs/cgroup` writable in following conditons:&#xA;1. when runc is executed inside the user namespace, and the `config.json` does not specify the cgroup namespace to be unshared (e.g.., `(docker|podman|nerdctl) run --cgroupns=host`, with Rootless Docker/Podman/nerdctl)&#xA;2. or, when runc is executed outside the user namespace, and `/sys` is mounted with `rbind, ro` (e.g., `runc spec --rootless`; this condition is very rare)&#xA;&#xA;A container may gain the write access to user-owned cgroup hierarchy `/sys/fs/cgroup/user.slice/...` on the host .&#xA;Other users&#39;s cgroup hierarchies are not affected.&#xA;&#xA;### Patches&#xA;v1.1.5 (planned)&#xA;&#xA;### Workarounds&#xA;- Condition 1: Unshare the cgroup namespace (`(docker|podman|nerdctl) run --cgroupns=private)`. This is the default behavior of Docker/Podman/nerdctl on cgroup v2 hosts.&#xA;- Condition 2 (very rare): add `/sys/fs/cgroup` to `maskedPaths`&#xA;</description>
      <pubDate>Thu, 30 Mar 2023 20:17:26 +0000</pubDate>
    </item>
    <item>
      <title>Opencontainers runc Incorrect Authorization vulnerability</title>
      <link>https://github.com/advisories/GHSA-vpvm-3wq2-2wvm</link>
      <description>runc 1.0.0-rc95 through 1.1.4 has Incorrect Access Control leading to Escalation of Privileges, related to `libcontainer/rootfs_linux.go`. To exploit this, an attacker must be able to spawn two containers with custom volume-mount configurations, and be able to run custom images. NOTE: this issue exists because of a CVE-2019-19921 regression.</description>
      <pubDate>Wed, 16 Aug 2023 13:15:43 +0000</pubDate>
    </item>
    <item>
      <title>Incorrect Authorization in runc</title>
      <link>https://github.com/advisories/GHSA-fgv8-vj5c-2ppq</link>
      <description>runc through 1.0.0-rc8, as used in Docker through 19.03.2-ce and other products, allows AppArmor restriction bypass because libcontainer/rootfs_linux.go incorrectly checks mount targets, and thus a malicious Docker image can mount over a /proc directory.</description>
      <pubDate>Fri, 24 Feb 2023 17:01:50 +0000</pubDate>
    </item>
    <item>
      <title>Default inheritable capabilities for linux container should be empty</title>
      <link>https://github.com/advisories/GHSA-f3fp-gc8g-vw66</link>
      <description>### Impact&#xA;&#xA;A bug was found in runc where `runc exec --cap` executed processes with non-empty inheritable Linux process capabilities, creating an atypical Linux environment and enabling programs with inheritable file capabilities to elevate those capabilities to the permitted set during execve(2).&#xA;&#xA;This bug did not affect the container security sandbox as the inheritable set never contained more capabilities than were included in the container&#39;s bounding set.&#xA;&#xA;### Patches&#xA;This bug has been fixed in runc 1.1.2. Users should update to this version as soon as possible.&#xA;&#xA;This fix changes `runc exec --cap` behavior such that the additional capabilities granted to the process being executed (as specified via `--cap` arguments) do not include inheritable capabilities.&#xA;&#xA;In addition, `runc spec` is changed to not set any inheritable capabilities in the created example OCI spec (`config.json`) file.&#xA;&#xA;### Credits&#xA;The opencontainers project would like to thank [Andrew G. Morgan](https://github.com/AndrewGMorgan) for responsibly disclosing this issue in accordance with the [opencontainers org security policy](https://github.com/opencontainers/.github/blob/master/SECURITY.md).&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* [Open an issue](https://github.com/opencontainers/runc/issues/new)&#xA;* Email us at [security@opencontainers.org](mailto:security@opencontainers.org) if you think you’ve found a security bug</description>
      <pubDate>Mon, 27 Mar 2023 22:23:51 +0000</pubDate>
    </item>
    <item>
      <title>devices resource list treated as a blacklist by default</title>
      <link>https://github.com/advisories/GHSA-g54h-m393-cpwq</link>
      <description>### Impact&#xA;Contrary to the [OCI runtime specification](https://github.com/opencontainers/runtime-spec/blob/v1.0.2/config-linux.md#device-whitelist), `runc`&#39;s implementation of the `linux.resources.devices` list was a black-list by default. This means that users who created their own `config.json` objects and didn&#39;t prefix a deny-all rule (`{&#34;allow&#34;: false, &#34;permissions&#34;: &#34;rwm&#34;}` or equivalent) were not provided protection by the `devices` cgroup. This would allow malicious containers (with sufficient privileges) to create arbitrary device inodes (assuming they have `CAP_MKNOD`) and operate on any device inodes they may have access to (assuming they have regular Unix DAC permissions).&#xA;&#xA;However, most (if not all) programs that make use of `runc` include this deny-all rule. This was most likely added before the specification mandated a white-list of devices, and the fact that all programs wrote their own deny-all rule obscured the existence of this bug for several years. In fact, even the specification&#39;s examples include a default deny-all rule! We therefore believe that while this is a security bug (and has been fixed as such), it was almost certainly not exploitable in the wild due to the inclusion of default deny-all rules by all known users of `runc` -- hence why this advisory has low severity.&#xA;&#xA;### Patches&#xA;This issue has been fixed in [a patch that was part of a larger rework of the devices cgroup code in runc](https://github.com/opencontainers/runc/pull/2391) -- which lead to the discovery of this security bug. Users should upgrade to 1.0.0-rc91 as soon as it is released, or wait for your distribution to backport the relevant fixes.&#xA;&#xA;### Workarounds&#xA;If you are using `runc` directly, ensure that there is a deny-all entry at the beginning of `linux.resources.devices` -- such an entry would look like `{&#34;allow&#34;: false, &#34;permissions&#34;: &#34;rwm&#34;}` (all other fields are ignored, though `type` must be set to `&#34;a&#34;` or `null` if it is present).&#xA;&#xA;Users which consume `runc` through another program should check whether their containers are operating under a white-list -- this can be done by reading `/sys/fs/cgroup/devices/devices.list` inside the container. If the file contains only the entry `a *:* rwm` (meaning the cgroup is in black-list mode, which likely means &#34;allow all device access&#34;) then your containers are vulnerable to this issue.&#xA;&#xA;As always, we recommend **in the strongest possible terms** that all of our users enable user namespaces on all of their workloads (or pressure their vendors to do so). User namespaces are one of the most significant defense-in-depth protections you can enable for containers, and have prevented many container-related vulnerabilities (both kernel 0days as well as bugs in container runtimes, such as this one).&#xA;&#xA;### References&#xA;* https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/devices.html&#xA;* [opencontainers/runtime-spec/config-linux.md#device-whitelist](https://github.com/opencontainers/runtime-spec/blob/v1.0.2/config-linux.md#device-whitelist)&#xA;* https://github.com/opencontainers/runc/pull/2391&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* [Open an issue in this repo](https://github.com/opencontainers/runc/issues/new).&#xA;* Email us at &lt;security@opencontainers.org&gt;.</description>
      <pubDate>Mon, 09 Jan 2023 05:05:06 +0000</pubDate>
    </item>
    <item>
      <title>mount destinations can be swapped via symlink-exchange to cause mounts outside the rootfs</title>
      <link>https://github.com/advisories/GHSA-c3xm-pvg7-gh7r</link>
      <description>### Summary&#xA;&#xA;runc 1.0.0-rc94 and earlier are vulnerable to a symlink exchange attack whereby&#xA;an attacker can request a seemingly-innocuous container configuration that&#xA;actually results in the host filesystem being bind-mounted into the container&#xA;(allowing for a container escape). CVE-2021-30465 has been assigned for this&#xA;issue.&#xA;&#xA;An attacker must have the ability to start containers using some kind of custom&#xA;volume configuration, and while recommended container hardening mechanisms such&#xA;as LSMs (AppArmor/SELinux) and user namespaces will restrict the amount of&#xA;damage an attacker could do, they do not block this attack outright. We have a&#xA;reproducer using Kubernetes (and the below description mentions&#xA;Kubernetes-specific paths), but this is not a Kubernetes-specific issue.&#xA;&#xA;The now-released [runc v1.0.0-rc95][release] contains a fix for this issue, we&#xA;recommend users update as soon as possible.&#xA;&#xA;[release]: https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc95&#xA;&#xA;### Details&#xA;&#xA;In circumstances where a container is being started, and runc is mounting&#xA;inside a volume shared with another container (which is conducting a&#xA;symlink-exchange attack), runc can be tricked into mounting outside of the&#xA;container rootfs by swapping the target of a mount with a symlink due to a&#xA;time-of-check-to-time-of-use (TOCTTOU) flaw. This is fairly similar in style to&#xA;previous TOCTTOU attacks (and is a problem we are working on solving with&#xA;libpathrs).&#xA;&#xA;However, this alone is not useful because this happens inside a mount namespace&#xA;with `MS_SLAVE` propagation applied to `/` (meaning that the mount doesn&#39;t&#xA;appear on the host -- it&#39;s only a &#34;host-side mount&#34; inside the container&#39;s&#xA;namespace). To exploit this, you must have additional mount entries in the&#xA;configuration that use some subpath of the mounted-over host path as a source&#xA;for a subsequent mount.&#xA;&#xA;However, it turns out with some container orchestrators (such as Kubernetes --&#xA;though it is very likely that other downstream users of runc could have similar&#xA;behaviour be accessible to untrusted users), the existence of additional volume&#xA;management infrastructure allows this attack to be applied to gain access to&#xA;the host filesystem without requiring the attacker to have completely arbitrary&#xA;control over container configuration.&#xA;&#xA;In the case of Kubernetes, this is exploitable by creating a symlink in a&#xA;volume to the top-level (well-known) directory where volumes are sourced from&#xA;(for instance,&#xA;`/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir`), and then&#xA;using that symlink as the target of a mount. The source of the mount is an&#xA;attacker controlled directory, and thus the source directory from which&#xA;subsequent mounts will occur is an attacker-controlled directory. Thus the&#xA;attacker can first place a symlink to `/` in their malicious source directory&#xA;with the name of a volume, and a subsequent mount in the container will&#xA;bind-mount `/` into the container.&#xA;&#xA;Applying this attack requires the attacker to start containers with a slightly&#xA;peculiar volume configuration (though not explicitly malicious-looking such as&#xA;bind-mounting `/` into the container explicitly), and be able to run malicious&#xA;code in a container that shares volumes with said volume configuration. It&#xA;helps the attacker if the host paths used for volume management are well known,&#xA;though this is not a hard requirement.&#xA;&#xA;### Patches&#xA;This has been patched in runc 1.0.0-rc95, and users should upgrade as soon as&#xA;possible. The patch itself can be found [here](https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f).&#xA;&#xA;### Workarounds&#xA;&#xA;There are no known workarounds for this issue.&#xA;&#xA;However, users who enforce running containers with more confined security&#xA;profiles (such as reduced capabilities, not running code as root in the&#xA;container, user namespaces, AppArmor/SELinux, and seccomp) will restrict what&#xA;an attacker can do in the case of a container breakout -- we recommend users&#xA;make use of strict security profiles if possible (most notably user namespaces&#xA;-- which can massively restrict the impact a container breakout can have on the&#xA;host system).&#xA;&#xA;### References&#xA;* [commit](https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f)&#xA;* [seclists public disclosure](https://www.openwall.com/lists/oss-security/2021/05/19/2)&#xA;&#xA;### Credit&#xA;&#xA;Thanks to Etienne Champetier for discovering and disclosing this vulnerability,&#xA;to Noah Meyerhans for writing the first draft of this patch, and to Samuel Karp&#xA;for testing it.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [our issue tracker](https://github.com/opencontainers/runc/issues).&#xA;* Email us at &lt;security@opencontainers.org&gt;.</description>
      <pubDate>Mon, 27 Mar 2023 22:23:46 +0000</pubDate>
    </item>
    <item>
      <title>Information Exposure in RunC</title>
      <link>https://github.com/advisories/GHSA-gp4j-w3vj-7299</link>
      <description>RunC allowed additional container processes via &#39;runc exec&#39; to be ptraced by the pid 1 of the container.  This allows the main processes of the container, if running as root, to gain access to file-descriptors of these new processes during the initialization and can lead to container escapes or modification of runC state before the process is fully placed inside the container.</description>
      <pubDate>Mon, 09 Jan 2023 05:04:47 +0000</pubDate>
    </item>
    <item>
      <title>Incorrect Authorization in imgcrypt</title>
      <link>https://github.com/advisories/GHSA-8v99-48m9-c8pm</link>
      <description>Imgcrypt implements a function `CheckAuthorization()` that is supposed to check whether a user is authorized to access an encrypted image given the keys that the user has provided on the command line that would enable decryption of the image. The check is to prevent that a user can start a container from an image that has previously been decrypted by another user on the same system and therefore a decrypted version of the image layers may be already available in the cache locally.&#xA;&#xA;The failure occurs when an image with a ManifestList is used and the architecture of the local host is not the first one in the ManifestList. In the version prior to the fix, only the first architecture in the list was tested, which may not have its layers available locally (were not pulled) since it cannot be run on the host architecture. Therefore, the verdict on unavailable layers was that the image could be run anticipating that image run failure would occur later due to the layers not being available. However, this verdict to allow the image to run lead to other architectures in the ManifestList be able to run an image without providing keys if that image had previously been decrypted. The fixed version now skips over irrelevant architectures and tests the Manifest of the local architecture, if available.&#xA;&#xA;Known projects that use the `CheckAuthorization()` of imgcrypt is for example the ctr-enc client tool provided by imgcrypt. In this implementation, the call to `CheckAuthorization()` is used on the client side and could therefore also be easily circumvented by a modified client tool not calling this function.&#xA;&#xA;In relation to the vulnerability in ctr-enc, affected environments would have to allow different users to invoke ctr-enc indirectly using some sort of management stack that gives user indirect access to ctr-enc.&#xA;&#xA;The patch has been applied to imgcrypt v1.1.4. Workarounds may include usage of different namespaces for each remote user.</description>
      <pubDate>Tue, 14 Feb 2023 17:47:26 +0000</pubDate>
    </item>
    <item>
      <title>CRI-O vulnerable to /etc/passwd tampering resulting in Privilege Escalation</title>
      <link>https://github.com/advisories/GHSA-cm9x-c3rh-7rc4</link>
      <description>### Impact&#xA;It is possible to craft an environment variable with newlines to add entries to a container&#39;s /etc/passwd. It is possible to circumvent admission validation of username/UID by adding such an entry.&#xA;&#xA;Note: because the pod author is in control of the container&#39;s /etc/passwd, this is not considered a new risk factor. However, this advisory is being opened for transparency and as a way of tracking fixes.&#xA;&#xA;### Patches&#xA;1.26.0 will have the fix. More patches will be posted as they&#39;re available.&#xA;&#xA;### Workarounds&#xA;Additional security controls like SELinux should prevent any damage a container is able to do with root on the host. Using SELinux is recommended because this class of attack is already possible by manually editing the container&#39;s /etc/passwd &#xA;&#xA;### References&#xA;</description>
      <pubDate>Thu, 09 Nov 2023 05:04:57 +0000</pubDate>
    </item>
    <item>
      <title>CRI-O incorrect handling of supplementary groups may lead to sensitive information disclosure</title>
      <link>https://github.com/advisories/GHSA-phjr-8j92-w5v7</link>
      <description>Incorrect handling of the supplementary groups in the CRI-O container engine might lead to sensitive information disclosure or possible data modification if an attacker has direct access to the affected container where supplementary groups are used to set access permissions and is able to execute a binary code in that container.</description>
      <pubDate>Tue, 31 Jan 2023 05:04:13 +0000</pubDate>
    </item>
    <item>
      <title>Node DOS by way of memory exhaustion through ExecSync request in CRI-O</title>
      <link>https://github.com/advisories/GHSA-fcm2-6c3h-pg6j</link>
      <description>### Description&#xA;An ExecSync request runs a command in a container and returns the output to the Kubelet. It is used for readiness and liveness probes within a pod. The way CRI-O runs ExecSync commands is through conmon. CRI-O asks conmon to start the process, and conmon writes the output to disk. CRI-O then reads the output and returns it to the Kubelet.&#xA;&#xA;If the output of the command is large enough, it is possible to exhaust the memory (or disk usage) of the node. The following deployment is an example yaml file that will output around 8GB of ‘A’ characters, which would be written to disk by conmon and read by CRI-O.&#xA;&#xA;```yaml&#xA;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: nginx-deployment100&#xA;spec:&#xA;  selector:&#xA;    matchLabels:&#xA;      app: nginx&#xA;  replicas: 2&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: nginx&#xA;    spec:&#xA;      containers:&#xA;      - name: nginx&#xA;        image: nginx:1.14.2&#xA;        lifecycle:&#xA;          postStart:&#xA;            exec:&#xA;              command: [&#34;/bin/sh&#34;, &#34;-c&#34;, &#34;seq 1 50000000`; do echo -n &#39;aaaaaaaaaaaaaaaa&#39;; done&#34;]&#xA;```&#xA;&#xA;### Impact&#xA;It is possible for the node to be exhausted of memory or disk space, depending on the node the command is being run on. What is further problematic is that the memory and disk usage aren&#39;t attributed to the container, as this file and its processing are implementation details of CRI-O. The consequence of the exhaustion is that other services on the node, e.g. other containers, will be unable to allocate memory and thus causing a denial of service.&#xA;&#xA;### Patches&#xA;This vulnerability will be fixed in 1.24.1, 1.23.3, 1.22.5, v1.21.8, v1.20.8, v1.19.7&#xA;&#xA;### Workarounds&#xA;At the time of writing, no workaround exists other than ensuring only trusted images are used.&#xA;&#xA;### References&#xA;https://github.com/containerd/containerd/security/advisories/GHSA-5ffw-gxpp-mxpf&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).&#xA;&#xA;### Credits&#xA;Disclosed by Ada Logics in a security audit sponsored by CNCF and facilitated by OSTIF.&#xA;</description>
      <pubDate>Mon, 24 Jul 2023 19:33:45 +0000</pubDate>
    </item>
    <item>
      <title>Node DOS by way of memory exhaustion through ExecSync request in CRI-O</title>
      <link>https://github.com/advisories/GHSA-fcm2-6c3h-pg6j</link>
      <description>### Description&#xA;An ExecSync request runs a command in a container and returns the output to the Kubelet. It is used for readiness and liveness probes within a pod. The way CRI-O runs ExecSync commands is through conmon. CRI-O asks conmon to start the process, and conmon writes the output to disk. CRI-O then reads the output and returns it to the Kubelet.&#xA;&#xA;If the output of the command is large enough, it is possible to exhaust the memory (or disk usage) of the node. The following deployment is an example yaml file that will output around 8GB of ‘A’ characters, which would be written to disk by conmon and read by CRI-O.&#xA;&#xA;```yaml&#xA;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: nginx-deployment100&#xA;spec:&#xA;  selector:&#xA;    matchLabels:&#xA;      app: nginx&#xA;  replicas: 2&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: nginx&#xA;    spec:&#xA;      containers:&#xA;      - name: nginx&#xA;        image: nginx:1.14.2&#xA;        lifecycle:&#xA;          postStart:&#xA;            exec:&#xA;              command: [&#34;/bin/sh&#34;, &#34;-c&#34;, &#34;seq 1 50000000`; do echo -n &#39;aaaaaaaaaaaaaaaa&#39;; done&#34;]&#xA;```&#xA;&#xA;### Impact&#xA;It is possible for the node to be exhausted of memory or disk space, depending on the node the command is being run on. What is further problematic is that the memory and disk usage aren&#39;t attributed to the container, as this file and its processing are implementation details of CRI-O. The consequence of the exhaustion is that other services on the node, e.g. other containers, will be unable to allocate memory and thus causing a denial of service.&#xA;&#xA;### Patches&#xA;This vulnerability will be fixed in 1.24.1, 1.23.3, 1.22.5, v1.21.8, v1.20.8, v1.19.7&#xA;&#xA;### Workarounds&#xA;At the time of writing, no workaround exists other than ensuring only trusted images are used.&#xA;&#xA;### References&#xA;https://github.com/containerd/containerd/security/advisories/GHSA-5ffw-gxpp-mxpf&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).&#xA;&#xA;### Credits&#xA;Disclosed by Ada Logics in a security audit sponsored by CNCF and facilitated by OSTIF.&#xA;</description>
      <pubDate>Mon, 24 Jul 2023 19:33:45 +0000</pubDate>
    </item>
    <item>
      <title>Node DOS by way of memory exhaustion through ExecSync request in CRI-O</title>
      <link>https://github.com/advisories/GHSA-fcm2-6c3h-pg6j</link>
      <description>### Description&#xA;An ExecSync request runs a command in a container and returns the output to the Kubelet. It is used for readiness and liveness probes within a pod. The way CRI-O runs ExecSync commands is through conmon. CRI-O asks conmon to start the process, and conmon writes the output to disk. CRI-O then reads the output and returns it to the Kubelet.&#xA;&#xA;If the output of the command is large enough, it is possible to exhaust the memory (or disk usage) of the node. The following deployment is an example yaml file that will output around 8GB of ‘A’ characters, which would be written to disk by conmon and read by CRI-O.&#xA;&#xA;```yaml&#xA;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: nginx-deployment100&#xA;spec:&#xA;  selector:&#xA;    matchLabels:&#xA;      app: nginx&#xA;  replicas: 2&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: nginx&#xA;    spec:&#xA;      containers:&#xA;      - name: nginx&#xA;        image: nginx:1.14.2&#xA;        lifecycle:&#xA;          postStart:&#xA;            exec:&#xA;              command: [&#34;/bin/sh&#34;, &#34;-c&#34;, &#34;seq 1 50000000`; do echo -n &#39;aaaaaaaaaaaaaaaa&#39;; done&#34;]&#xA;```&#xA;&#xA;### Impact&#xA;It is possible for the node to be exhausted of memory or disk space, depending on the node the command is being run on. What is further problematic is that the memory and disk usage aren&#39;t attributed to the container, as this file and its processing are implementation details of CRI-O. The consequence of the exhaustion is that other services on the node, e.g. other containers, will be unable to allocate memory and thus causing a denial of service.&#xA;&#xA;### Patches&#xA;This vulnerability will be fixed in 1.24.1, 1.23.3, 1.22.5, v1.21.8, v1.20.8, v1.19.7&#xA;&#xA;### Workarounds&#xA;At the time of writing, no workaround exists other than ensuring only trusted images are used.&#xA;&#xA;### References&#xA;https://github.com/containerd/containerd/security/advisories/GHSA-5ffw-gxpp-mxpf&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).&#xA;&#xA;### Credits&#xA;Disclosed by Ada Logics in a security audit sponsored by CNCF and facilitated by OSTIF.&#xA;</description>
      <pubDate>Mon, 24 Jul 2023 19:33:45 +0000</pubDate>
    </item>
    <item>
      <title>Incorrect Default Permissions in CRI-O</title>
      <link>https://github.com/advisories/GHSA-4hj2-r2pm-3hc6</link>
      <description>### Impact&#xA;&#xA;A bug was found in CRI-O where containers were incorrectly started with non-empty inheritable Linux process capabilities, creating an atypical Linux environment and enabling programs with inheritable file capabilities to elevate those capabilities to the permitted set during `execve(2)`.  Normally, when executable programs have specified permitted file capabilities, otherwise unprivileged users and processes can execute those programs and gain the specified file capabilities up to the bounding set.  Due to this bug, containers which included executable programs with inheritable file capabilities allowed otherwise unprivileged users and processes to additionally gain these inheritable file capabilities up to the container&#39;s bounding set.  Containers which use Linux users and groups to perform privilege separation inside the container are most directly impacted.&#xA;&#xA;This bug did not affect the container security sandbox as the inheritable set never contained more capabilities than were included in the container&#39;s bounding set.&#xA;&#xA;&#xA;### Patches&#xA;&#xA;This bug will been fixed in the following versions of CRI-O:&#xA;- v1.24.0&#xA;&#xA;Users should update to the version corresponding to their minor release as soon as possible.  Running containers should be stopped, deleted, and recreated for the inheritable capabilities to be reset.&#xA;&#xA;This fix changes CRI-O behavior such that containers are started with a more typical Linux environment.  Refer to `capabilities(7)` for a description of how capabilities work.  Note that permitted file capabilities continue to allow for privileges to be raised up to the container&#39;s bounding set and that processes may add capabilities to their own inheritable set up to the container&#39;s bounding set per the rules described in the manual page.  In all cases the container&#39;s bounding set provides an upper bound on the capabilities that can be assumed and provides for the container security sandbox.&#xA;&#xA;### Workarounds&#xA;&#xA;The entrypoint of a container can be modified to use a utility like `capsh(1)` to drop inheritable capabilities prior to the primary process starting.&#xA;&#xA;### Credits&#xA;&#xA;CRI-O would like to thank [Andrew G. Morgan](https://github.com/AndrewGMorgan) for responsibly disclosing this issue, as well as the Moby (Docker Engine) project for working with the other container engines in coordinating a fix.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* [Open an issue](https://github.com/cri-o/cri-o/issues/new)&#xA;* Email us at [cncf-crio-security@lists.cncf.io](cncf-crio-security@lists.cncf.io) if you think you’ve found a security bug&#xA;&#xA;------------------&#xA;&#xA;https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L&#xA;4.8/Medium&#xA;&#xA;|Metric&#x9;|Value&#x9;|Comments&#x9;|&#xA;|---&#x9;|---&#x9;|---&#x9;|&#xA;|Attack Vector (AV)&#x9;|Local&#x9;|An attacker requires local control to launch a container with files that have inheritable capabilities. &#x9;|&#xA;|Attack Complexity (AC)&#x9;|Low&#x9;|Modifying a file to have inheritable capabilities is not difficult.&#x9;|&#xA;|Privileges Required (PR)&#x9;|Low&#x9;|An attacker requires enough privilege to cause a container to be launched with a compromised image.  Moby&#39;s API is typically bound to a local Unix domain socket and requires calls to be made from a process that is either UID 0 or present in the configured group.&#x9;|&#xA;|User Interaction (UI)&#x9;|Required&#x9;|An attacker must cause the compromised image to be run.&#x9;|&#xA;|Scope (S)&#x9;|Unchanged&#x9;|The container boundary set by Moby, including the bounding capability set, is not modified.  A successful attack gains access to privileges and resources within the boundary, not outside of it.&#x9;|&#xA;|Confidentiality (C)&#x9;|Low&#x9;|An attacker may gain access to some confidential information through elevation of CAP_CHOWN, CAP_DAC_OVERRIDE, CAP_FOWNER, CAP_SETFCAP, or CAP_SETPCAP, but the exposed information is limited to that which is already inside the container.&#x9;|&#xA;|Integrity (I)&#x9;|Low&#x9;|An attacker may be able to tamper with data inside the container through elevation of CAP_CHOWN, CAP_DAC_OVERRIDE, CAP_FOWNER, CAP_SETFCAP, or CAP_SETPCAP, or spoof packets with CAP_NET_RAW, but the tampered data is limited to that which is already inside the container.&#x9;|&#xA;|Availability (A)&#x9;|Low&#x9;|An attacker may be able to affect the availability of an application running inside the container through elevation of CAP_KILL or CAP_NET_RAW, or may be able to affect availability through tampering with file dependencies.&#x9;|&#xA;&#xA;</description>
      <pubDate>Fri, 27 Jan 2023 05:01:57 +0000</pubDate>
    </item>
    <item>
      <title>Code Injection in CRI-O</title>
      <link>https://github.com/advisories/GHSA-6x2m-w449-qwx7</link>
      <description>### Impact&#xA;A flaw introduced in CRI-O version 1.19 which an attacker can use to bypass the safeguards and set arbitrary kernel parameters on the host. As a result, anyone with rights to deploy a pod on a Kubernetes cluster that uses the CRI-O runtime can abuse the `kernel.core_pattern` kernel parameter to achieve container escape and arbitrary code execution as root on any node in the cluster.&#xA;&#xA;### Patches&#xA;The patches will be present in 1.19.6, 1.20.7, 1.21.6, 1.22.3, 1.23.2, 1.24.0&#xA;&#xA;### Workarounds&#xA;- Users can set manage_ns_lifecycle to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;- An admission webhook could be created to deny pods that specify a `+` in the sysctl value of a pod.&#xA;- A [PodSecurityPolicy](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/#podsecuritypolicy) [deprecated] could be created, specifying all sysctls as forbidden like so: &#xA;```&#xA;apiVersion: policy/v1beta1&#xA;kind: PodSecurityPolicy&#xA;metadata:&#xA;  name: sysctl-psp&#xA;spec:&#xA;  forbiddenSysctls:&#xA;    - &#34;*&#34;&#xA;```&#xA;However, this option will not work if any sysctls are required by any pods in the cluster.&#xA;&#xA;&#xA;### Credits&#xA;Credit for finding this vulnerability goes to John Walker and Manoj Ahuje of Crowdstrike. The CRI-O community deeply thanks them for the report.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).&#xA;</description>
      <pubDate>Fri, 27 Jan 2023 05:00:43 +0000</pubDate>
    </item>
    <item>
      <title>Code Injection in CRI-O</title>
      <link>https://github.com/advisories/GHSA-6x2m-w449-qwx7</link>
      <description>### Impact&#xA;A flaw introduced in CRI-O version 1.19 which an attacker can use to bypass the safeguards and set arbitrary kernel parameters on the host. As a result, anyone with rights to deploy a pod on a Kubernetes cluster that uses the CRI-O runtime can abuse the `kernel.core_pattern` kernel parameter to achieve container escape and arbitrary code execution as root on any node in the cluster.&#xA;&#xA;### Patches&#xA;The patches will be present in 1.19.6, 1.20.7, 1.21.6, 1.22.3, 1.23.2, 1.24.0&#xA;&#xA;### Workarounds&#xA;- Users can set manage_ns_lifecycle to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;- An admission webhook could be created to deny pods that specify a `+` in the sysctl value of a pod.&#xA;- A [PodSecurityPolicy](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/#podsecuritypolicy) [deprecated] could be created, specifying all sysctls as forbidden like so: &#xA;```&#xA;apiVersion: policy/v1beta1&#xA;kind: PodSecurityPolicy&#xA;metadata:&#xA;  name: sysctl-psp&#xA;spec:&#xA;  forbiddenSysctls:&#xA;    - &#34;*&#34;&#xA;```&#xA;However, this option will not work if any sysctls are required by any pods in the cluster.&#xA;&#xA;&#xA;### Credits&#xA;Credit for finding this vulnerability goes to John Walker and Manoj Ahuje of Crowdstrike. The CRI-O community deeply thanks them for the report.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).&#xA;</description>
      <pubDate>Fri, 27 Jan 2023 05:00:43 +0000</pubDate>
    </item>
    <item>
      <title>Code Injection in CRI-O</title>
      <link>https://github.com/advisories/GHSA-6x2m-w449-qwx7</link>
      <description>### Impact&#xA;A flaw introduced in CRI-O version 1.19 which an attacker can use to bypass the safeguards and set arbitrary kernel parameters on the host. As a result, anyone with rights to deploy a pod on a Kubernetes cluster that uses the CRI-O runtime can abuse the `kernel.core_pattern` kernel parameter to achieve container escape and arbitrary code execution as root on any node in the cluster.&#xA;&#xA;### Patches&#xA;The patches will be present in 1.19.6, 1.20.7, 1.21.6, 1.22.3, 1.23.2, 1.24.0&#xA;&#xA;### Workarounds&#xA;- Users can set manage_ns_lifecycle to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;- An admission webhook could be created to deny pods that specify a `+` in the sysctl value of a pod.&#xA;- A [PodSecurityPolicy](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/#podsecuritypolicy) [deprecated] could be created, specifying all sysctls as forbidden like so: &#xA;```&#xA;apiVersion: policy/v1beta1&#xA;kind: PodSecurityPolicy&#xA;metadata:&#xA;  name: sysctl-psp&#xA;spec:&#xA;  forbiddenSysctls:&#xA;    - &#34;*&#34;&#xA;```&#xA;However, this option will not work if any sysctls are required by any pods in the cluster.&#xA;&#xA;&#xA;### Credits&#xA;Credit for finding this vulnerability goes to John Walker and Manoj Ahuje of Crowdstrike. The CRI-O community deeply thanks them for the report.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).&#xA;</description>
      <pubDate>Fri, 27 Jan 2023 05:00:43 +0000</pubDate>
    </item>
    <item>
      <title>Code Injection in CRI-O</title>
      <link>https://github.com/advisories/GHSA-6x2m-w449-qwx7</link>
      <description>### Impact&#xA;A flaw introduced in CRI-O version 1.19 which an attacker can use to bypass the safeguards and set arbitrary kernel parameters on the host. As a result, anyone with rights to deploy a pod on a Kubernetes cluster that uses the CRI-O runtime can abuse the `kernel.core_pattern` kernel parameter to achieve container escape and arbitrary code execution as root on any node in the cluster.&#xA;&#xA;### Patches&#xA;The patches will be present in 1.19.6, 1.20.7, 1.21.6, 1.22.3, 1.23.2, 1.24.0&#xA;&#xA;### Workarounds&#xA;- Users can set manage_ns_lifecycle to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;- An admission webhook could be created to deny pods that specify a `+` in the sysctl value of a pod.&#xA;- A [PodSecurityPolicy](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/#podsecuritypolicy) [deprecated] could be created, specifying all sysctls as forbidden like so: &#xA;```&#xA;apiVersion: policy/v1beta1&#xA;kind: PodSecurityPolicy&#xA;metadata:&#xA;  name: sysctl-psp&#xA;spec:&#xA;  forbiddenSysctls:&#xA;    - &#34;*&#34;&#xA;```&#xA;However, this option will not work if any sysctls are required by any pods in the cluster.&#xA;&#xA;&#xA;### Credits&#xA;Credit for finding this vulnerability goes to John Walker and Manoj Ahuje of Crowdstrike. The CRI-O community deeply thanks them for the report.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).&#xA;</description>
      <pubDate>Fri, 27 Jan 2023 05:00:43 +0000</pubDate>
    </item>
    <item>
      <title>Code Injection in CRI-O</title>
      <link>https://github.com/advisories/GHSA-6x2m-w449-qwx7</link>
      <description>### Impact&#xA;A flaw introduced in CRI-O version 1.19 which an attacker can use to bypass the safeguards and set arbitrary kernel parameters on the host. As a result, anyone with rights to deploy a pod on a Kubernetes cluster that uses the CRI-O runtime can abuse the `kernel.core_pattern` kernel parameter to achieve container escape and arbitrary code execution as root on any node in the cluster.&#xA;&#xA;### Patches&#xA;The patches will be present in 1.19.6, 1.20.7, 1.21.6, 1.22.3, 1.23.2, 1.24.0&#xA;&#xA;### Workarounds&#xA;- Users can set manage_ns_lifecycle to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;- An admission webhook could be created to deny pods that specify a `+` in the sysctl value of a pod.&#xA;- A [PodSecurityPolicy](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/#podsecuritypolicy) [deprecated] could be created, specifying all sysctls as forbidden like so: &#xA;```&#xA;apiVersion: policy/v1beta1&#xA;kind: PodSecurityPolicy&#xA;metadata:&#xA;  name: sysctl-psp&#xA;spec:&#xA;  forbiddenSysctls:&#xA;    - &#34;*&#34;&#xA;```&#xA;However, this option will not work if any sysctls are required by any pods in the cluster.&#xA;&#xA;&#xA;### Credits&#xA;Credit for finding this vulnerability goes to John Walker and Manoj Ahuje of Crowdstrike. The CRI-O community deeply thanks them for the report.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).&#xA;</description>
      <pubDate>Fri, 27 Jan 2023 05:00:43 +0000</pubDate>
    </item>
    <item>
      <title>Sysctls applied to containers with host IPC or host network namespaces can affect the host</title>
      <link>https://github.com/advisories/GHSA-w2j5-3rcx-vx7x</link>
      <description>### Impact&#xA;Before setting the sysctls for a pod, the pods namespaces must be unshared (created). However, in cases where the pod is using a host network or IPC namespace, a bug in CRI-O caused the namespace creating tool [pinns](https://github.com/cri-o/cri-o/tree/main/pinns/) to configure the sysctls of the host. This allows a malicious user to set sysctls on the host, assuming they have access to hostNetwork and hostIPC.&#xA;&#xA;Any CRI-O cluster after CRI-O 1.18 that drops the infra container&#xA;1.22 and 1.23 clusters drop infra container by default, and are thus vulnerable by default.&#xA;&#xA;### Patches&#xA;CRI-O versions 1.24.0, 1.23.1, 1.22.2, 1.21.5, 1.20.6, 1.19.5 all have the patches.&#xA;&#xA;### Workarounds&#xA;Users can set `manage_ns_lifecycle` to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;An admission webhook could also be created to deny pods that use host IPC or network namespaces and also attempt to configure sysctls related to that namespace.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).</description>
      <pubDate>Wed, 11 Jan 2023 05:05:49 +0000</pubDate>
    </item>
    <item>
      <title>Sysctls applied to containers with host IPC or host network namespaces can affect the host</title>
      <link>https://github.com/advisories/GHSA-w2j5-3rcx-vx7x</link>
      <description>### Impact&#xA;Before setting the sysctls for a pod, the pods namespaces must be unshared (created). However, in cases where the pod is using a host network or IPC namespace, a bug in CRI-O caused the namespace creating tool [pinns](https://github.com/cri-o/cri-o/tree/main/pinns/) to configure the sysctls of the host. This allows a malicious user to set sysctls on the host, assuming they have access to hostNetwork and hostIPC.&#xA;&#xA;Any CRI-O cluster after CRI-O 1.18 that drops the infra container&#xA;1.22 and 1.23 clusters drop infra container by default, and are thus vulnerable by default.&#xA;&#xA;### Patches&#xA;CRI-O versions 1.24.0, 1.23.1, 1.22.2, 1.21.5, 1.20.6, 1.19.5 all have the patches.&#xA;&#xA;### Workarounds&#xA;Users can set `manage_ns_lifecycle` to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;An admission webhook could also be created to deny pods that use host IPC or network namespaces and also attempt to configure sysctls related to that namespace.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).</description>
      <pubDate>Wed, 11 Jan 2023 05:05:49 +0000</pubDate>
    </item>
    <item>
      <title>Sysctls applied to containers with host IPC or host network namespaces can affect the host</title>
      <link>https://github.com/advisories/GHSA-w2j5-3rcx-vx7x</link>
      <description>### Impact&#xA;Before setting the sysctls for a pod, the pods namespaces must be unshared (created). However, in cases where the pod is using a host network or IPC namespace, a bug in CRI-O caused the namespace creating tool [pinns](https://github.com/cri-o/cri-o/tree/main/pinns/) to configure the sysctls of the host. This allows a malicious user to set sysctls on the host, assuming they have access to hostNetwork and hostIPC.&#xA;&#xA;Any CRI-O cluster after CRI-O 1.18 that drops the infra container&#xA;1.22 and 1.23 clusters drop infra container by default, and are thus vulnerable by default.&#xA;&#xA;### Patches&#xA;CRI-O versions 1.24.0, 1.23.1, 1.22.2, 1.21.5, 1.20.6, 1.19.5 all have the patches.&#xA;&#xA;### Workarounds&#xA;Users can set `manage_ns_lifecycle` to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;An admission webhook could also be created to deny pods that use host IPC or network namespaces and also attempt to configure sysctls related to that namespace.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).</description>
      <pubDate>Wed, 11 Jan 2023 05:05:49 +0000</pubDate>
    </item>
    <item>
      <title>Sysctls applied to containers with host IPC or host network namespaces can affect the host</title>
      <link>https://github.com/advisories/GHSA-w2j5-3rcx-vx7x</link>
      <description>### Impact&#xA;Before setting the sysctls for a pod, the pods namespaces must be unshared (created). However, in cases where the pod is using a host network or IPC namespace, a bug in CRI-O caused the namespace creating tool [pinns](https://github.com/cri-o/cri-o/tree/main/pinns/) to configure the sysctls of the host. This allows a malicious user to set sysctls on the host, assuming they have access to hostNetwork and hostIPC.&#xA;&#xA;Any CRI-O cluster after CRI-O 1.18 that drops the infra container&#xA;1.22 and 1.23 clusters drop infra container by default, and are thus vulnerable by default.&#xA;&#xA;### Patches&#xA;CRI-O versions 1.24.0, 1.23.1, 1.22.2, 1.21.5, 1.20.6, 1.19.5 all have the patches.&#xA;&#xA;### Workarounds&#xA;Users can set `manage_ns_lifecycle` to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;An admission webhook could also be created to deny pods that use host IPC or network namespaces and also attempt to configure sysctls related to that namespace.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).</description>
      <pubDate>Wed, 11 Jan 2023 05:05:49 +0000</pubDate>
    </item>
    <item>
      <title>Sysctls applied to containers with host IPC or host network namespaces can affect the host</title>
      <link>https://github.com/advisories/GHSA-w2j5-3rcx-vx7x</link>
      <description>### Impact&#xA;Before setting the sysctls for a pod, the pods namespaces must be unshared (created). However, in cases where the pod is using a host network or IPC namespace, a bug in CRI-O caused the namespace creating tool [pinns](https://github.com/cri-o/cri-o/tree/main/pinns/) to configure the sysctls of the host. This allows a malicious user to set sysctls on the host, assuming they have access to hostNetwork and hostIPC.&#xA;&#xA;Any CRI-O cluster after CRI-O 1.18 that drops the infra container&#xA;1.22 and 1.23 clusters drop infra container by default, and are thus vulnerable by default.&#xA;&#xA;### Patches&#xA;CRI-O versions 1.24.0, 1.23.1, 1.22.2, 1.21.5, 1.20.6, 1.19.5 all have the patches.&#xA;&#xA;### Workarounds&#xA;Users can set `manage_ns_lifecycle` to false, which causes the sysctls to be configured by the OCI runtime, which typically filter these cases. This option is available in 1.20 and 1.19. Newer versions don&#39;t have this option.&#xA;An admission webhook could also be created to deny pods that use host IPC or network namespaces and also attempt to configure sysctls related to that namespace.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [the CRI-O repo](http://github.com/cri-o/cri-o/issues)&#xA;* To make a report, email your vulnerability to the private&#xA;[cncf-crio-security@lists.cncf.io](mailto:cncf-crio-security@lists.cncf.io) list&#xA;with the security details and the details expected for [all CRI-O bug&#xA;reports](https://github.com/cri-o/cri-o/blob/main/.github/ISSUE_TEMPLATE/bug-report.yml).</description>
      <pubDate>Wed, 11 Jan 2023 05:05:49 +0000</pubDate>
    </item>
    <item>
      <title>Incorrect Permission Assignment for Critical Resource in CRI-O</title>
      <link>https://github.com/advisories/GHSA-jqmc-79gx-7g8p</link>
      <description>An incorrect sysctls validation vulnerability was found in CRI-O 1.18 and earlier. The sysctls from the list of &#34;safe&#34; sysctls specified for the cluster will be applied to the host if an attacker is able to create a pod with a hostIPC and hostNetwork kernel namespace.</description>
      <pubDate>Fri, 03 Feb 2023 05:05:59 +0000</pubDate>
    </item>
    <item>
      <title>coreDNS vulnerable to Improper Restriction of Communication Channel to Intended Endpoints</title>
      <link>https://github.com/advisories/GHSA-h828-v5pv-33qx</link>
      <description>A flaw was found in coreDNS. This flaw allows a malicious user to redirect traffic intended for external top-level domains (TLD) to a pod they control by creating projects and namespaces that match the TLD.</description>
      <pubDate>Tue, 14 Mar 2023 19:39:28 +0000</pubDate>
    </item>
    <item>
      <title>coreDNS vulnerable to Improper Restriction of Communication Channel to Intended Endpoints</title>
      <link>https://github.com/advisories/GHSA-ch7v-37xg-75ph</link>
      <description>A flaw was found in coreDNS. This flaw allows a malicious user to reroute internal calls to some internal services that were accessed by the FQDN in a format of &lt;service&gt;.&lt;namespace&gt;.svc.</description>
      <pubDate>Tue, 14 Mar 2023 19:39:53 +0000</pubDate>
    </item>
    <item>
      <title>Improper random number generation in github.com/coredns/coredns</title>
      <link>https://github.com/advisories/GHSA-gv9j-4w24-q7vx</link>
      <description>### Impact&#xA;&#xA;CoreDNS before 1.6.6 (using go DNS package &lt; 1.1.25) improperly generates random numbers because math/rand is used. The TXID becomes predictable, leading to response forgeries.&#xA;&#xA;### Patches&#xA;The problem has been fixed in 1.6.6+.&#xA;&#xA;### References&#xA;- [CVE-2019-19794](https://nvd.nist.gov/vuln/detail/CVE-2019-19794)&#xA;&#xA;### For more information&#xA;Please consult [our security guide](https://github.com/coredns/coredns/blob/master/.github/SECURITY.md) for more information regarding our security process.&#xA;</description>
      <pubDate>Wed, 11 Jan 2023 05:05:23 +0000</pubDate>
    </item>
  </channel>
</rss>