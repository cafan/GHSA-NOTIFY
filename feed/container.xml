<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Container Software GHSA Feeds</title>
    <link>https://raw.githubusercontent.com/ssst0n3/GHSA-NOTIFY/main/output/feed.xml</link>
    <description></description>
    <managingEditor>ssst0n3@gmail.com (ssst0n3)</managingEditor>
    <pubDate>Thu, 12 May 2022 06:42:14 +0000</pubDate>
    <item>
      <title>Path Traversal in Docker</title>
      <link>https://github.com/advisories/GHSA-vj3f-3286-r4pf</link>
      <description>Path traversal vulnerability in Docker before 1.3.3 allows remote attackers to write to arbitrary files and bypass a container protection mechanism via a full pathname in a symlink in an (1) image or (2) build in a Dockerfile.</description>
      <pubDate>Tue, 19 Apr 2022 19:03:27 +0000</pubDate>
    </item>
    <item>
      <title>Privilege Escalation in Docker</title>
      <link>https://github.com/advisories/GHSA-wxj3-qwv4-cvfm</link>
      <description>Docker 1.0.0 uses world-readable and world-writable permissions on the management socket, which allows local users to gain privileges via unspecified vectors.</description>
      <pubDate>Tue, 15 Feb 2022 00:40:44 +0000</pubDate>
    </item>
    <item>
      <title>Arbitrary Code Execution in Docker</title>
      <link>https://github.com/advisories/GHSA-5qgp-p5jc-w2rm</link>
      <description>Docker before 1.3.2 allows remote attackers to write to arbitrary files and execute arbitrary code via a (1) symlink or (2) hard link attack in an image archive in a (a) pull or (b) load operation.</description>
      <pubDate>Tue, 15 Feb 2022 00:41:12 +0000</pubDate>
    </item>
    <item>
      <title>Directory Traversal in Docker</title>
      <link>https://github.com/advisories/GHSA-qmmc-jppf-32wv</link>
      <description>Docker before 1.3.3 does not properly validate image IDs, which allows remote attackers to conduct path traversal attacks and spoof repositories via a crafted image in a (1) &#34;docker load&#34; operation or (2) &#34;registry communications.&#34;</description>
      <pubDate>Tue, 15 Feb 2022 00:41:14 +0000</pubDate>
    </item>
    <item>
      <title>Symlink Attack in Libcontainer and Docker Engine</title>
      <link>https://github.com/advisories/GHSA-g7v2-2qxx-wjrw</link>
      <description>Libcontainer and Docker Engine before 1.6.1 opens the file-descriptor passed to the pid-1 process before performing the chroot, which allows local users to gain privileges via a symlink attack in an image.</description>
      <pubDate>Tue, 15 Feb 2022 01:18:02 +0000</pubDate>
    </item>
    <item>
      <title>Access Restriction Bypass in Docker</title>
      <link>https://github.com/advisories/GHSA-44gg-pmqr-4669</link>
      <description>Docker 1.3.0 through 1.3.1 allows remote attackers to modify the default run profile of image containers and possibly bypass the container by applying unspecified security options to an image.</description>
      <pubDate>Tue, 12 Apr 2022 22:38:18 +0000</pubDate>
    </item>
    <item>
      <title>Arbitrary File Write in Libcontainer</title>
      <link>https://github.com/advisories/GHSA-g44j-7vp3-68cv</link>
      <description>Libcontainer 1.6.0, as used in Docker Engine, allows local users to escape containerization (&#34;mount namespace breakout&#34;) and write to arbitrary file on the host system via a symlink attack in an image when respawning a container.</description>
      <pubDate>Tue, 12 Apr 2022 22:13:08 +0000</pubDate>
    </item>
    <item>
      <title>Man-in-the-Middle (MitM)</title>
      <link>https://github.com/advisories/GHSA-8w94-cf6g-c8mg</link>
      <description>Docker before 1.3.1 and docker-py before 0.5.3 fall back to HTTP when the HTTPS connection to the registry fails, which allows man-in-the-middle attackers to conduct downgrade attacks and obtain authentication and image data by leveraging a network position between the client and the registry to block HTTPS traffic.</description>
      <pubDate>Tue, 12 Apr 2022 22:53:42 +0000</pubDate>
    </item>
    <item>
      <title>Arbitrary Code Execution</title>
      <link>https://github.com/advisories/GHSA-997c-fj8j-rq5h</link>
      <description>Docker 1.3.2 allows remote attackers to execute arbitrary code with root privileges via a crafted (1) image or (2) build in a Dockerfile in an LZMA (.xz) archive, related to the chroot for archive extraction.</description>
      <pubDate>Tue, 12 Apr 2022 22:01:45 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI plugin: Insecure handling of image volumes</title>
      <link>https://github.com/advisories/GHSA-crp2-qrr5-8pq7</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd where containers launched through containerd’s CRI implementation with a specially-crafted image configuration could gain access to read-only copies of arbitrary files and directories on the host.  This may bypass any policy-based enforcement on container setup (including a Kubernetes Pod Security Policy) and expose potentially sensitive information.  Kubernetes and crictl can both be configured to use containerd’s CRI implementation.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.1, 1.5.10 and 1.4.13.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images are used.&#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank Felix Wilhelm of Google Project Zero for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md).&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Tue, 29 Mar 2022 19:11:09 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI plugin: Insecure handling of image volumes</title>
      <link>https://github.com/advisories/GHSA-crp2-qrr5-8pq7</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd where containers launched through containerd’s CRI implementation with a specially-crafted image configuration could gain access to read-only copies of arbitrary files and directories on the host.  This may bypass any policy-based enforcement on container setup (including a Kubernetes Pod Security Policy) and expose potentially sensitive information.  Kubernetes and crictl can both be configured to use containerd’s CRI implementation.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.1, 1.5.10 and 1.4.13.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images are used.&#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank Felix Wilhelm of Google Project Zero for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md).&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Tue, 29 Mar 2022 19:11:09 +0000</pubDate>
    </item>
    <item>
      <title>containerd CRI plugin: Insecure handling of image volumes</title>
      <link>https://github.com/advisories/GHSA-crp2-qrr5-8pq7</link>
      <description>### Impact&#xA;&#xA;A bug was found in containerd where containers launched through containerd’s CRI implementation with a specially-crafted image configuration could gain access to read-only copies of arbitrary files and directories on the host.  This may bypass any policy-based enforcement on container setup (including a Kubernetes Pod Security Policy) and expose potentially sensitive information.  Kubernetes and crictl can both be configured to use containerd’s CRI implementation.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.6.1, 1.5.10 and 1.4.13.  Users should update to these versions to resolve the issue.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that only trusted images are used.&#xA;&#xA;### Credits&#xA;&#xA;The containerd project would like to thank Felix Wilhelm of Google Project Zero for responsibly disclosing this issue in accordance with the [containerd security policy](https://github.com/containerd/project/blob/main/SECURITY.md).&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Tue, 29 Mar 2022 19:11:09 +0000</pubDate>
    </item>
    <item>
      <title>Unprivileged pod using `hostPath` can side-step active LSM when it is SELinux</title>
      <link>https://github.com/advisories/GHSA-mvff-h3cj-wj9c</link>
      <description>### Impact&#xA;&#xA;Containers launched through containerd’s CRI implementation on Linux systems which use the SELinux security module and containerd versions since v1.5.0 can cause arbitrary files and directories on the host to be relabeled to match the container process label through the use of specially-configured bind mounts in a hostPath volume. This relabeling elevates permissions for the container, granting full read/write access over the affected files and directories. Kubernetes and crictl can both be configured to use containerd’s CRI implementation.&#xA;&#xA;If you are not using containerd’s CRI implementation (through one of the mechanisms described above), you are not affected by this issue.&#xA;&#xA;### Patches&#xA;&#xA;This bug has been fixed in containerd 1.5.9.  Because file labels persist independently of containerd, users should both update to these versions as soon as they are released and validate that all files on their host are correctly labeled.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure that no sensitive files or directories are used as a hostPath volume source location.  Policy enforcement mechanisms such a Kubernetes Pod Security Policy [AllowedHostPaths](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems) may be specified to limit the files and directories that can be bind-mounted to containers.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Wed, 16 Feb 2022 22:03:34 +0000</pubDate>
    </item>
    <item>
      <title>Ambiguous OCI manifest parsing</title>
      <link>https://github.com/advisories/GHSA-5j5w-g665-5m35</link>
      <description>### Impact&#xA;&#xA;In the OCI Distribution Specification version 1.0.0 and prior and in the OCI Image Specification version 1.0.1 and prior, manifest and index documents are ambiguous without an accompanying Content-Type HTTP header.  Versions of containerd prior to 1.4.12 and 1.5.8 treat the Content-Type header as trusted and deserialize the document according to that header.  If the Content-Type header changed between pulls of the same ambiguous document (with the same digest), the document may be interpreted differently, meaning that the digest alone is insufficient to unambiguously identify the content of the image.&#xA;&#xA;### Patches&#xA;&#xA;This issue has been fixed in containerd 1.4.12 and 1.5.8.  Image pulls for manifests that contain a “manifests” field or indices which contain a “layers” field are rejected.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure you only pull images from trusted sources.&#xA;&#xA;### References&#xA;&#xA;https://github.com/opencontainers/distribution-spec/security/advisories/GHSA-mc8v-mgrf-8f4m&#xA;https://github.com/opencontainers/image-spec/security/advisories/GHSA-77vh-xpmg-72qh&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Thu, 18 Nov 2021 16:08:58 +0000</pubDate>
    </item>
    <item>
      <title>Ambiguous OCI manifest parsing</title>
      <link>https://github.com/advisories/GHSA-5j5w-g665-5m35</link>
      <description>### Impact&#xA;&#xA;In the OCI Distribution Specification version 1.0.0 and prior and in the OCI Image Specification version 1.0.1 and prior, manifest and index documents are ambiguous without an accompanying Content-Type HTTP header.  Versions of containerd prior to 1.4.12 and 1.5.8 treat the Content-Type header as trusted and deserialize the document according to that header.  If the Content-Type header changed between pulls of the same ambiguous document (with the same digest), the document may be interpreted differently, meaning that the digest alone is insufficient to unambiguously identify the content of the image.&#xA;&#xA;### Patches&#xA;&#xA;This issue has been fixed in containerd 1.4.12 and 1.5.8.  Image pulls for manifests that contain a “manifests” field or indices which contain a “layers” field are rejected.&#xA;&#xA;### Workarounds&#xA;&#xA;Ensure you only pull images from trusted sources.&#xA;&#xA;### References&#xA;&#xA;https://github.com/opencontainers/distribution-spec/security/advisories/GHSA-mc8v-mgrf-8f4m&#xA;https://github.com/opencontainers/image-spec/security/advisories/GHSA-77vh-xpmg-72qh&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)</description>
      <pubDate>Thu, 18 Nov 2021 16:08:58 +0000</pubDate>
    </item>
    <item>
      <title>Insufficiently restricted permissions on plugin directories</title>
      <link>https://github.com/advisories/GHSA-c2h3-6mxw-7mvq</link>
      <description>### Impact&#xA;A bug was found in containerd where container root directories and some plugins had insufficiently restricted permissions, allowing otherwise unprivileged Linux users to traverse directory contents and execute programs. When containers included executable programs with extended permission bits (such as setuid), unprivileged Linux users could discover and execute those programs. When the UID of an unprivileged Linux user on the host collided with the file owner or group inside a container, the unprivileged Linux user on the host could discover, read, and modify those files.&#xA;&#xA;### Patches&#xA;This vulnerability has been fixed in containerd 1.4.11 and containerd 1.5.7. Users should update to these version when they are released and may restart containers or update directory permissions to mitigate the vulnerability.&#xA;&#xA;### Workarounds&#xA;Limit access to the host to trusted users. Update directory permission on container bundles directories. &#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory: &#xA;* Open an issue in [github.com/containerd/containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;</description>
      <pubDate>Thu, 18 Nov 2021 15:14:52 +0000</pubDate>
    </item>
    <item>
      <title>Insufficiently restricted permissions on plugin directories</title>
      <link>https://github.com/advisories/GHSA-c2h3-6mxw-7mvq</link>
      <description>### Impact&#xA;A bug was found in containerd where container root directories and some plugins had insufficiently restricted permissions, allowing otherwise unprivileged Linux users to traverse directory contents and execute programs. When containers included executable programs with extended permission bits (such as setuid), unprivileged Linux users could discover and execute those programs. When the UID of an unprivileged Linux user on the host collided with the file owner or group inside a container, the unprivileged Linux user on the host could discover, read, and modify those files.&#xA;&#xA;### Patches&#xA;This vulnerability has been fixed in containerd 1.4.11 and containerd 1.5.7. Users should update to these version when they are released and may restart containers or update directory permissions to mitigate the vulnerability.&#xA;&#xA;### Workarounds&#xA;Limit access to the host to trusted users. Update directory permission on container bundles directories. &#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory: &#xA;* Open an issue in [github.com/containerd/containerd](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at [security@containerd.io](mailto:security@containerd.io)&#xA;</description>
      <pubDate>Thu, 18 Nov 2021 15:14:52 +0000</pubDate>
    </item>
    <item>
      <title>Archive package allows chmod of file outside of unpack target directory</title>
      <link>https://github.com/advisories/GHSA-c72p-9xmj-rx3w</link>
      <description>## Impact&#xA;&#xA;A bug was found in containerd where pulling and extracting a specially-crafted container image can result in Unix file permission changes for existing files in the host’s filesystem.  Changes to file permissions can deny access to the expected owner of the file, widen access to others, or set extended bits like setuid, setgid, and sticky.  This bug does not directly allow files to be read, modified, or executed without an additional cooperating process.&#xA;&#xA;## Patches&#xA;&#xA;This bug has been fixed in containerd 1.5.4 and 1.4.8.  Users should update to these versions as soon as they are released.  Running containers do not need to be restarted.&#xA;&#xA;## Workarounds&#xA;&#xA;Ensure you only pull images from trusted sources.&#xA;&#xA;Linux security modules (LSMs) like SELinux and AppArmor can limit the files potentially affected by this bug through policies and profiles that prevent containerd from interacting with unexpected files.&#xA;&#xA;## For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* [Open an issue](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at security@containerd.io if you think you’ve found a security bug.</description>
      <pubDate>Thu, 21 Oct 2021 13:16:23 +0000</pubDate>
    </item>
    <item>
      <title>Archive package allows chmod of file outside of unpack target directory</title>
      <link>https://github.com/advisories/GHSA-c72p-9xmj-rx3w</link>
      <description>## Impact&#xA;&#xA;A bug was found in containerd where pulling and extracting a specially-crafted container image can result in Unix file permission changes for existing files in the host’s filesystem.  Changes to file permissions can deny access to the expected owner of the file, widen access to others, or set extended bits like setuid, setgid, and sticky.  This bug does not directly allow files to be read, modified, or executed without an additional cooperating process.&#xA;&#xA;## Patches&#xA;&#xA;This bug has been fixed in containerd 1.5.4 and 1.4.8.  Users should update to these versions as soon as they are released.  Running containers do not need to be restarted.&#xA;&#xA;## Workarounds&#xA;&#xA;Ensure you only pull images from trusted sources.&#xA;&#xA;Linux security modules (LSMs) like SELinux and AppArmor can limit the files potentially affected by this bug through policies and profiles that prevent containerd from interacting with unexpected files.&#xA;&#xA;## For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;&#xA;* [Open an issue](https://github.com/containerd/containerd/issues/new/choose)&#xA;* Email us at security@containerd.io if you think you’ve found a security bug.</description>
      <pubDate>Thu, 21 Oct 2021 13:16:23 +0000</pubDate>
    </item>
    <item>
      <title>Incorrect Authorization in runc</title>
      <link>https://github.com/advisories/GHSA-fgv8-vj5c-2ppq</link>
      <description>runc through 1.0.0-rc8, as used in Docker through 19.03.2-ce and other products, allows AppArmor restriction bypass because libcontainer/rootfs_linux.go incorrectly checks mount targets, and thus a malicious Docker image can mount over a /proc directory.</description>
      <pubDate>Sat, 26 Feb 2022 01:52:03 +0000</pubDate>
    </item>
    <item>
      <title>Overflow in netlink bytemsg length field allows attacker to override netlink-based container configuration</title>
      <link>https://github.com/advisories/GHSA-v95c-p5hm-xq8f</link>
      <description>### Impact&#xA;&#xA;In runc, [netlink](https://www.man7.org/linux/man-pages/man7/netlink.7.html) is used internally as a serialization system for specifying the relevant container configuration to the C portion of our code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration.&#xA;&#xA;This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces.&#xA;&#xA;Prior to 9c444070ec7bb83995dbc0185da68284da71c554, in practice it was fairly difficult to specify an arbitrary-length netlink message with most container runtimes. The only user-controlled byte array was the namespace paths attributes which can be specified in runc&#39;s `config.json`, but as far as we can tell no container runtime gives raw access to that configuration setting -- and having raw access to that setting **would allow the attacker to disable namespace protections entirely anyway** (setting them to `/proc/1/ns/...` for instance). In addition, each namespace path is limited to 4096 bytes (with only 7 namespaces supported by runc at the moment) meaning that even with custom namespace paths it appears an attacker still cannot shove enough bytes into the netlink bytemsg in order to overflow the uint16 counter.&#xA;&#xA;However, out of an abundance of caution (given how old this bug is) we decided to treat it as a potentially exploitable vulnerability with a low severity. After 9c444070ec7bb83995dbc0185da68284da71c554 (which was not present in any release of runc prior to the discovery of this bug), all mount paths are included as a giant netlink message which means that this bug becomes significantly more exploitable in more reasonable threat scenarios.&#xA;&#xA;The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure), though as mentioned above it appears this bug was not practically exploitable on any released version of runc to date.&#xA;&#xA;### Patches&#xA;The patch for this is d72d057ba794164c3cce9451a00b72a78b25e1ae and runc 1.0.3 was released with this bug fixed.&#xA;&#xA;### Workarounds&#xA;To the extent this is exploitable, disallowing untrusted namespace paths in container configuration should eliminate all practical ways of exploiting this bug. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.&#xA;&#xA;### References&#xA;* commit d72d057ba794 (&#34;runc init: avoid netlink message length overflows&#34;)&#xA;* https://bugs.chromium.org/p/project-zero/issues/detail?id=2241&#xA;&#xA;### Credits&#xA;Thanks to Felix Wilhelm from Google Project Zero for discovering and reporting this vulnerability. In particular, the fact they found this vulnerability so quickly, before we made a 1.1 release of runc (which would&#39;ve been vulnerable) was quite impressive.&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [our repo](https://github.com/opencontainers/runc)&#xA;</description>
      <pubDate>Tue, 19 Apr 2022 19:03:16 +0000</pubDate>
    </item>
    <item>
      <title>devices resource list treated as a blacklist by default</title>
      <link>https://github.com/advisories/GHSA-g54h-m393-cpwq</link>
      <description>### Impact&#xA;Contrary to the [OCI runtime specification](https://github.com/opencontainers/runtime-spec/blob/v1.0.2/config-linux.md#device-whitelist), `runc`&#39;s implementation of the `linux.resources.devices` list was a black-list by default. This means that users who created their own `config.json` objects and didn&#39;t prefix a deny-all rule (`{&#34;allow&#34;: false, &#34;permissions&#34;: &#34;rwm&#34;}` or equivalent) were not provided protection by the `devices` cgroup. This would allow malicious containers (with sufficient privileges) to create arbitrary device inodes (assuming they have `CAP_MKNOD`) and operate on any device inodes they may have access to (assuming they have regular Unix DAC permissions).&#xA;&#xA;However, most (if not all) programs that make use of `runc` include this deny-all rule. This was most likely added before the specification mandated a white-list of devices, and the fact that all programs wrote their own deny-all rule obscured the existence of this bug for several years. In fact, even the specification&#39;s examples include a default deny-all rule! We therefore believe that while this is a security bug (and has been fixed as such), it was almost certainly not exploitable in the wild due to the inclusion of default deny-all rules by all known users of `runc` -- hence why this advisory has low severity.&#xA;&#xA;### Patches&#xA;This issue has been fixed in [a patch that was part of a larger rework of the devices cgroup code in runc](https://github.com/opencontainers/runc/pull/2391) -- which lead to the discovery of this security bug. Users should upgrade to 1.0.0-rc91 as soon as it is released, or wait for your distribution to backport the relevant fixes.&#xA;&#xA;### Workarounds&#xA;If you are using `runc` directly, ensure that there is a deny-all entry at the beginning of `linux.resources.devices` -- such an entry would look like `{&#34;allow&#34;: false, &#34;permissions&#34;: &#34;rwm&#34;}` (all other fields are ignored, though `type` must be set to `&#34;a&#34;` or `null` if it is present).&#xA;&#xA;Users which consume `runc` through another program should check whether their containers are operating under a white-list -- this can be done by reading `/sys/fs/cgroup/devices/devices.list` inside the container. If the file contains only the entry `a *:* rwm` (meaning the cgroup is in black-list mode, which likely means &#34;allow all device access&#34;) then your containers are vulnerable to this issue.&#xA;&#xA;As always, we recommend **in the strongest possible terms** that all of our users enable user namespaces on all of their workloads (or pressure their vendors to do so). User namespaces are one of the most significant defense-in-depth protections you can enable for containers, and have prevented many container-related vulnerabilities (both kernel 0days as well as bugs in container runtimes, such as this one).&#xA;&#xA;### References&#xA;* https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/devices.html&#xA;* [opencontainers/runtime-spec/config-linux.md#device-whitelist](https://github.com/opencontainers/runtime-spec/blob/v1.0.2/config-linux.md#device-whitelist)&#xA;* https://github.com/opencontainers/runc/pull/2391&#xA;&#xA;### For more information&#xA;If you have any questions or comments about this advisory:&#xA;* [Open an issue in this repo](https://github.com/opencontainers/runc/issues/new).&#xA;* Email us at &lt;security@opencontainers.org&gt;.</description>
      <pubDate>Tue, 19 Apr 2022 19:02:28 +0000</pubDate>
    </item>
    <item>
      <title>mount destinations can be swapped via symlink-exchange to cause mounts outside the rootfs</title>
      <link>https://github.com/advisories/GHSA-c3xm-pvg7-gh7r</link>
      <description>### Summary&#xA;&#xA;runc 1.0.0-rc94 and earlier are vulnerable to a symlink exchange attack whereby&#xA;an attacker can request a seemingly-innocuous container configuration that&#xA;actually results in the host filesystem being bind-mounted into the container&#xA;(allowing for a container escape). CVE-2021-30465 has been assigned for this&#xA;issue.&#xA;&#xA;An attacker must have the ability to start containers using some kind of custom&#xA;volume configuration, and while recommended container hardening mechanisms such&#xA;as LSMs (AppArmor/SELinux) and user namespaces will restrict the amount of&#xA;damage an attacker could do, they do not block this attack outright. We have a&#xA;reproducer using Kubernetes (and the below description mentions&#xA;Kubernetes-specific paths), but this is not a Kubernetes-specific issue.&#xA;&#xA;The now-released [runc v1.0.0-rc95][release] contains a fix for this issue, we&#xA;recommend users update as soon as possible.&#xA;&#xA;[release]: https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc95&#xA;&#xA;### Details&#xA;&#xA;In circumstances where a container is being started, and runc is mounting&#xA;inside a volume shared with another container (which is conducting a&#xA;symlink-exchange attack), runc can be tricked into mounting outside of the&#xA;container rootfs by swapping the target of a mount with a symlink due to a&#xA;time-of-check-to-time-of-use (TOCTTOU) flaw. This is fairly similar in style to&#xA;previous TOCTTOU attacks (and is a problem we are working on solving with&#xA;libpathrs).&#xA;&#xA;However, this alone is not useful because this happens inside a mount namespace&#xA;with `MS_SLAVE` propagation applied to `/` (meaning that the mount doesn&#39;t&#xA;appear on the host -- it&#39;s only a &#34;host-side mount&#34; inside the container&#39;s&#xA;namespace). To exploit this, you must have additional mount entries in the&#xA;configuration that use some subpath of the mounted-over host path as a source&#xA;for a subsequent mount.&#xA;&#xA;However, it turns out with some container orchestrators (such as Kubernetes --&#xA;though it is very likely that other downstream users of runc could have similar&#xA;behaviour be accessible to untrusted users), the existence of additional volume&#xA;management infrastructure allows this attack to be applied to gain access to&#xA;the host filesystem without requiring the attacker to have completely arbitrary&#xA;control over container configuration.&#xA;&#xA;In the case of Kubernetes, this is exploitable by creating a symlink in a&#xA;volume to the top-level (well-known) directory where volumes are sourced from&#xA;(for instance,&#xA;`/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir`), and then&#xA;using that symlink as the target of a mount. The source of the mount is an&#xA;attacker controlled directory, and thus the source directory from which&#xA;subsequent mounts will occur is an attacker-controlled directory. Thus the&#xA;attacker can first place a symlink to `/` in their malicious source directory&#xA;with the name of a volume, and a subsequent mount in the container will&#xA;bind-mount `/` into the container.&#xA;&#xA;Applying this attack requires the attacker to start containers with a slightly&#xA;peculiar volume configuration (though not explicitly malicious-looking such as&#xA;bind-mounting `/` into the container explicitly), and be able to run malicious&#xA;code in a container that shares volumes with said volume configuration. It&#xA;helps the attacker if the host paths used for volume management are well known,&#xA;though this is not a hard requirement.&#xA;&#xA;### Patches&#xA;This has been patched in runc 1.0.0-rc95, and users should upgrade as soon as&#xA;possible. The patch itself can be found [here](https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f).&#xA;&#xA;### Workarounds&#xA;&#xA;There are no known workarounds for this issue.&#xA;&#xA;However, users who enforce running containers with more confined security&#xA;profiles (such as reduced capabilities, not running code as root in the&#xA;container, user namespaces, AppArmor/SELinux, and seccomp) will restrict what&#xA;an attacker can do in the case of a container breakout -- we recommend users&#xA;make use of strict security profiles if possible (most notably user namespaces&#xA;-- which can massively restrict the impact a container breakout can have on the&#xA;host system).&#xA;&#xA;### References&#xA;* [commit](https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f)&#xA;* [seclists public disclosure](https://www.openwall.com/lists/oss-security/2021/05/19/2)&#xA;&#xA;### Credit&#xA;&#xA;Thanks to Etienne Champetier for discovering and disclosing this vulnerability,&#xA;to Noah Meyerhans for writing the first draft of this patch, and to Samuel Karp&#xA;for testing it.&#xA;&#xA;### For more information&#xA;&#xA;If you have any questions or comments about this advisory:&#xA;* Open an issue in [our issue tracker](https://github.com/opencontainers/runc/issues).&#xA;* Email us at &lt;security@opencontainers.org&gt;.</description>
      <pubDate>Tue, 19 Apr 2022 19:02:53 +0000</pubDate>
    </item>
    <item>
      <title>Privilege Elevation in runc</title>
      <link>https://github.com/advisories/GHSA-q3j5-32m5-58c2</link>
      <description>libcontainer/user/user.go in runC before 0.1.0, as used in Docker before 1.11.2, improperly treats a numeric UID as a potential username, which allows local users to gain privileges via a numeric username in the password file in a container.</description>
      <pubDate>Mon, 20 Dec 2021 18:21:34 +0000</pubDate>
    </item>
    <item>
      <title>Information Exposure in RunC</title>
      <link>https://github.com/advisories/GHSA-gp4j-w3vj-7299</link>
      <description>RunC allowed additional container processes via &#39;runc exec&#39; to be ptraced by the pid 1 of the container.  This allows the main processes of the container, if running as root, to gain access to file-descriptors of these new processes during the initialization and can lead to container escapes or modification of runC state before the process is fully placed inside the container.</description>
      <pubDate>Mon, 20 Dec 2021 18:21:43 +0000</pubDate>
    </item>
    <item>
      <title>Incorrect Authorization in imgcrypt</title>
      <link>https://github.com/advisories/GHSA-8v99-48m9-c8pm</link>
      <description>Imgcrypt implements a function `CheckAuthorization()` that is supposed to check whether a user is authorized to access an encrypted image given the keys that the user has provided on the command line that would enable decryption of the image. The check is to prevent that a user can start a container from an image that has previously been decrypted by another user on the same system and therefore a decrypted version of the image layers may be already available in the cache locally.&#xA;&#xA;The failure occurs when an image with a ManifestList is used and the architecture of the local host is not the first one in the ManifestList. In the version prior to the fix, only the first architecture in the list was tested, which may not have its layers available locally (were not pulled) since it cannot be run on the host architecture. Therefore, the verdict on unavailable layers was that the image could be run anticipating that image run failure would occur later due to the layers not being available. However, this verdict to allow the image to run lead to other architectures in the ManifestList be able to run an image without providing keys if that image had previously been decrypted. The fixed version now skips over irrelevant architectures and tests the Manifest of the local architecture, if available.&#xA;&#xA;Known projects that use the `CheckAuthorization()` of imgcrypt is for example the ctr-enc client tool provided by imgcrypt. In this implementation, the call to `CheckAuthorization()` is used on the client side and could therefore also be easily circumvented by a modified client tool not calling this function.&#xA;&#xA;In relation to the vulnerability in ctr-enc, affected environments would have to allow different users to invoke ctr-enc indirectly using some sort of management stack that gives user indirect access to ctr-enc.&#xA;&#xA;The patch has been applied to imgcrypt v1.1.4. Workarounds may include usage of different namespaces for each remote user.</description>
      <pubDate>Wed, 13 Apr 2022 03:57:34 +0000</pubDate>
    </item>
  </channel>
</rss>